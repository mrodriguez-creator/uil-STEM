// UIL Computer Science – Object-Oriented Programming
const OOP_PROBLEMS = [

  // ── CLASSES & CONSTRUCTORS ──
  { id: "oo1", topic: "OOP", question: "What is the output?<pre><code>class Dog {\n  String name;\n  Dog(String n) { name = n; }\n}\nDog d = new Dog(\"Rex\");\nSystem.out.println(d.name);</code></pre>", choices: ["\"Rex\"", "null", "\"Dog\"", "Compilation error", "\"n\""], answer: 0, hint: "The constructor sets name = n, where n = \"Rex\"", explanation: "Constructor sets name = \"Rex\". d.name prints \"Rex\"." },
  { id: "oo2", topic: "OOP", question: "What is the default value of an uninitialized instance variable of type <code>String</code>?", choices: ["\"\"", "\"null\"", "null", "0", "Compilation error"], answer: 2, hint: "Object reference fields default to null if not explicitly initialized", explanation: "Uninitialized object references (including String) default to null." },
  { id: "oo3", topic: "OOP", question: "What is the output?<pre><code>class Counter {\n  static int count = 0;\n  Counter() { count++; }\n}\nnew Counter();\nnew Counter();\nnew Counter();\nSystem.out.println(Counter.count);</code></pre>", choices: ["0", "1", "2", "3", "Compilation error"], answer: 3, hint: "static variables are shared across all instances", explanation: "Each constructor call increments the shared static count. After 3 calls, count = 3." },
  { id: "oo4", topic: "OOP", question: "Which keyword makes a variable belong to the class rather than to individual objects?", choices: ["final", "static", "private", "abstract", "void"], answer: 1, hint: "This keyword means the member is shared by all instances", explanation: "The static keyword makes a variable belong to the class, shared by all instances." },

  // ── ENCAPSULATION ──
  { id: "oo5", topic: "OOP", question: "Which access modifier makes a field accessible only within its own class?", choices: ["public", "protected", "default", "private", "static"], answer: 3, hint: "This is the most restrictive access level", explanation: "private restricts access to only the declaring class." },
  { id: "oo6", topic: "OOP", question: "What is the purpose of getter and setter methods?", choices: ["To make code run faster", "To provide controlled access to private fields", "To make fields static", "To prevent inheritance", "To allow multiple constructors"], answer: 1, hint: "Getters/setters are a key part of encapsulation", explanation: "Getters and setters provide controlled access to private instance variables, enforcing encapsulation." },

  // ── INHERITANCE ──
  { id: "oo7", topic: "OOP", question: "What is the output?<pre><code>class Animal {\n  String speak() { return \"...\"; }\n}\nclass Dog extends Animal {\n  String speak() { return \"Woof\"; }\n}\nAnimal a = new Dog();\nSystem.out.println(a.speak());</code></pre>", choices: ["\"...\"", "\"Woof\"", "Compilation error", "Runtime error", "null"], answer: 1, hint: "The runtime type is Dog, so Dog's overridden speak() is called", explanation: "Polymorphism: a's runtime type is Dog. Dog.speak() returns \"Woof\"." },
  { id: "oo8", topic: "OOP", question: "What keyword is used to call a parent class constructor from a subclass?", choices: ["this", "super", "parent", "base", "extends"], answer: 1, hint: "This keyword refers to the superclass", explanation: "super() calls the parent class constructor. Must be the first statement in the subclass constructor." },
  { id: "oo9", topic: "OOP", question: "What is the output?<pre><code>class A {\n  A() { System.out.print(\"A \"); }\n}\nclass B extends A {\n  B() { System.out.print(\"B \"); }\n}\nnew B();</code></pre>", choices: ["\"A \"", "\"B \"", "\"A B \"", "\"B A \"", "Compilation error"], answer: 2, hint: "The parent constructor is called first (implicitly if not specified)", explanation: "When B() runs, it implicitly calls super() first → A's constructor prints \"A \", then B's prints \"B \"." },
  { id: "oo10", topic: "OOP", question: "Can a class in Java extend multiple classes?", choices: ["Yes, always", "Yes, with the implements keyword", "No, Java supports only single inheritance for classes", "Yes, using the extends keyword with commas", "Only if the classes are abstract"], answer: 2, hint: "Java does not support multiple inheritance of classes", explanation: "Java supports only single inheritance for classes. A class can extend exactly one parent class (but implement multiple interfaces)." },

  // ── OVERLOADING VS OVERRIDING ──
  { id: "oo11", topic: "OOP", question: "Which describes method <b>overloading</b>?", choices: ["Same name and parameters in a subclass", "Same name, different parameters in the same class", "Same name, different return type only", "Calling super's method", "Using the @Override annotation"], answer: 1, hint: "Overloading: same name, different parameter lists", explanation: "Method overloading = same method name with different parameter lists in the same class." },
  { id: "oo12", topic: "OOP", question: "What is the output?<pre><code>class Calc {\n  int add(int a, int b) { return a + b; }\n  double add(double a, double b) { return a + b; }\n}\nCalc c = new Calc();\nSystem.out.println(c.add(3, 4));\nSystem.out.println(c.add(1.5, 2.5));</code></pre>", choices: ["7 then 4.0", "7.0 then 4.0", "7 then 4", "Compilation error", "Runtime error"], answer: 0, hint: "Java chooses the method based on argument types: int→int version, double→double version", explanation: "add(3,4) calls the int version → 7. add(1.5,2.5) calls the double version → 4.0." },

  // ── ABSTRACT CLASSES ──
  { id: "oo13", topic: "OOP", question: "Can you create an instance of an abstract class?", choices: ["Yes", "No", "Only with the new keyword", "Only if it has a constructor", "Only in a static context"], answer: 1, hint: "Abstract classes cannot be instantiated directly", explanation: "No, abstract classes cannot be instantiated. You must create a concrete subclass." },
  { id: "oo14", topic: "OOP", question: "What happens if a class extends an abstract class but does not implement all abstract methods?", choices: ["It compiles normally", "It must be declared abstract itself", "It throws a RuntimeException", "The methods return null by default", "Only a warning is issued"], answer: 1, hint: "Unimplemented abstract methods force the subclass to also be abstract", explanation: "If a subclass doesn't implement all abstract methods, it must also be declared abstract." },

  // ── INTERFACES ──
  { id: "oo15", topic: "OOP", question: "How many interfaces can a Java class implement?", choices: ["0", "1", "2", "Any number", "Only if it extends nothing"], answer: 3, hint: "Java allows implementing multiple interfaces (but extending only one class)", explanation: "A Java class can implement any number of interfaces." },
  { id: "oo16", topic: "OOP", question: "What is the output?<pre><code>interface Greetable {\n  String greet();\n}\nclass Hello implements Greetable {\n  public String greet() { return \"Hi!\"; }\n}\nGreetable g = new Hello();\nSystem.out.println(g.greet());</code></pre>", choices: ["\"Hi!\"", "null", "Compilation error", "Runtime error", "\"Greetable\""], answer: 0, hint: "Hello implements greet(), so calling it through the interface works", explanation: "Hello implements Greetable.greet() → returns \"Hi!\". Polymorphism via interface." },

  // ── COMPARABLE / COMPARETO ──
  { id: "oo17", topic: "OOP", question: "What does <code>\"apple\".compareTo(\"banana\")</code> return?", choices: ["A negative number", "0", "A positive number", "true", "false"], answer: 0, hint: "compareTo returns negative if this string comes before the argument alphabetically", explanation: "\"apple\" < \"banana\" alphabetically. compareTo returns a negative number." },
  { id: "oo18", topic: "OOP", question: "If <code>a.compareTo(b) > 0</code>, which is true?", choices: ["a < b", "a == b", "a > b", "a equals b", "a is null"], answer: 2, hint: "Positive return means the calling object is greater", explanation: "compareTo > 0 means a > b in the natural ordering." },

  // ── OBJECT CLASS ──
  { id: "oo19", topic: "OOP", question: "What does the <code>equals()</code> method from Object class compare by default?", choices: ["Field values", "Hash codes", "Reference equality (same object)", "toString() output", "Class names"], answer: 2, hint: "The default equals() from Object uses == (reference comparison)", explanation: "Object's default equals() compares references (memory addresses), same as ==." },
  { id: "oo20", topic: "OOP", question: "What is the output?<pre><code>String a = new String(\"hi\");\nString b = new String(\"hi\");\nSystem.out.println(a == b);\nSystem.out.println(a.equals(b));</code></pre>", choices: ["true then true", "false then false", "true then false", "false then true", "Compilation error"], answer: 3, hint: "== compares references (different objects), equals() compares content", explanation: "a == b: false (different objects). a.equals(b): true (same content)." },

  // ── POLYMORPHISM & CASTING ──
  { id: "oo21", topic: "OOP", question: "What is the output?<pre><code>class Shape {\n  String type() { return \"Shape\"; }\n}\nclass Circle extends Shape {\n  String type() { return \"Circle\"; }\n}\nShape s = new Circle();\nSystem.out.println(s.type());</code></pre>", choices: ["\"Shape\"", "\"Circle\"", "Compilation error", "Runtime error", "null"], answer: 1, hint: "Dynamic dispatch: the runtime type (Circle) determines which method runs", explanation: "Polymorphism: s is a Circle at runtime. Circle.type() returns \"Circle\"." },
  { id: "oo22", topic: "OOP", question: "What is the output?<pre><code>Object obj = \"Hello\";\nString s = (String) obj;\nSystem.out.println(s.length());</code></pre>", choices: ["5", "Compilation error", "ClassCastException", "null", "\"Hello\""], answer: 0, hint: "obj is actually a String, so the cast succeeds", explanation: "obj references a String. Downcasting to String succeeds. \"Hello\".length() = 5." },
  { id: "oo23", topic: "OOP", question: "What happens here?<pre><code>Object obj = new Integer(5);\nString s = (String) obj;</code></pre>", choices: ["s = \"5\"", "s = null", "Compilation error", "ClassCastException at runtime", "s = \"Integer\""], answer: 3, hint: "Integer cannot be cast to String — they are unrelated types", explanation: "Integer is not a String. The cast compiles (both are Objects) but throws ClassCastException at runtime." },

  // ── FINAL & STATIC ──
  { id: "oo24", topic: "OOP", question: "What does <code>final</code> mean when applied to a method?", choices: ["The method cannot be called", "The method cannot be overridden", "The method is static", "The method has no return value", "The method is abstract"], answer: 1, hint: "final prevents subclasses from overriding the method", explanation: "A final method cannot be overridden in subclasses." },
  { id: "oo25", topic: "OOP", question: "What does <code>final</code> mean when applied to a variable?", choices: ["It becomes static", "It becomes private", "Its value cannot be changed after assignment", "It is automatically initialized to 0", "It can only hold integers"], answer: 2, hint: "final makes a variable a constant after initialization", explanation: "A final variable can only be assigned once; its value cannot change." },
];
