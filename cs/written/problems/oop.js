// UIL Computer Science – Object-Oriented Programming
// Covers: fill-in-the-blank, shared code block, inheritance/polymorphism traces, concept ID
// Uses out.print / out.println (UIL static import convention)
const OOP_PROBLEMS = [

  // ══════════════════════════════════════════
  //  FILL-IN-THE-BLANK (oo1 – oo7)
  // ══════════════════════════════════════════

  // oo1: super() call in subclass constructor
  { id: "oo1", topic: "OOP", question: "Which of the following could replace <code>&lt;1*&gt;</code> in the code to the right so that the code compiles and runs without error?<pre><code>class Vehicle {\n  String make;\n  Vehicle(String make) {\n    this.make = make;\n  }\n}\nclass Car extends Vehicle {\n  int doors;\n  Car(String make, int doors) {\n    &lt;1*&gt;;\n    this.doors = doors;\n  }\n}</code></pre>", choices: ["Vehicle(make)", "this(make)", "super(make)", "make = make", "super.Vehicle(make)"], answer: 2, hint: "To call a parent class constructor from a subclass, use the super keyword with arguments.", explanation: "super(make) calls Vehicle's constructor to initialize the make field. It must be the first statement in the subclass constructor. Vehicle(make) is not valid syntax; this(make) would call another Car constructor, not the parent." },

  // oo2: access modifier for encapsulation
  { id: "oo2", topic: "OOP", question: "Which of the following could replace <code>&lt;1*&gt;</code> in the code to the right so that the field <code>balance</code> is only accessible within the <code>Account</code> class itself?<pre><code>class Account {\n  &lt;1*&gt; double balance;\n  public double getBalance() {\n    return balance;\n  }\n  public void deposit(double amt) {\n    balance += amt;\n  }\n}</code></pre>", choices: ["public", "protected", "static", "private", "final"], answer: 3, hint: "Encapsulation restricts direct access to fields. Which modifier limits access to the declaring class only?", explanation: "private restricts access to the declaring class. public allows all access, protected allows subclass and same-package access, static and final do not control visibility." },

  // oo3: this.x = x in constructor
  { id: "oo3", topic: "OOP", question: "Which of the following could replace <code>&lt;1*&gt;</code> in the code to the right so that the constructor correctly initializes the <code>name</code> field?<pre><code>class Player {\n  String name;\n  int score;\n  Player(String name, int score) {\n    &lt;1*&gt;;\n    this.score = score;\n  }\n  String getName() { return name; }\n}</code></pre>", choices: ["name == name", "name = name", "this.name = name", "super.name = name", "Player.name = name"], answer: 2, hint: "When a parameter has the same name as a field, use this to distinguish the instance variable.", explanation: "this.name = name assigns the parameter to the instance field. name = name would just assign the parameter to itself, leaving the field null." },

  // oo4: abstract method declaration
  { id: "oo4", topic: "OOP", question: "Which of the following could replace <code>&lt;1*&gt;</code> in the code to the right so that any non-abstract subclass of <code>Shape</code> is <em>required</em> to provide its own <code>area()</code> method?<pre><code>abstract class Shape {\n  &lt;1*&gt;\n}\nclass Circle extends Shape {\n  double radius;\n  Circle(double r) { radius = r; }\n  public double area() {\n    return Math.PI * radius * radius;\n  }\n}</code></pre>", choices: ["double area() { return 0; }", "public abstract double area();", "public double area();", "abstract double area() { return 0; }", "void area();"], answer: 1, hint: "An abstract method has no body and forces subclasses to provide an implementation.", explanation: "public abstract double area(); declares a method with no body that Circle must override. Choice A compiles but does not force subclasses to override. Choice C is invalid (no body, no abstract). Choice D is invalid (abstract methods cannot have a body). Choice E has wrong return type." },

  // oo5: interface implements keyword
  { id: "oo5", topic: "OOP", question: "Which of the following could replace <code>&lt;1*&gt;</code> in the code to the right so that the code compiles?<pre><code>interface Printable {\n  void print();\n}\nclass Report &lt;1*&gt; Printable {\n  public void print() {\n    out.println(\"Report\");\n  }\n}</code></pre>", choices: ["extends", "implements", "inherits", "uses", "import"], answer: 1, hint: "A class uses a specific keyword to indicate it provides implementations for an interface's methods.", explanation: "A class uses implements to adopt an interface. extends is used for class-to-class inheritance. The other options are not valid Java keywords for this purpose." },

  // oo6: generic type parameter
  { id: "oo6", topic: "OOP", question: "Which of the following can <strong>NOT</strong> replace <code>&lt;1*&gt;</code> in the code to the right?<pre><code>class Box&lt;T&gt; {\n  T item;\n  Box(T item) { this.item = item; }\n  T getItem() { return item; }\n}\nBox&lt;&lt;1*&gt;&gt; b = new Box&lt;&gt;(42);\nout.println(b.getItem());</code></pre>", choices: ["int", "Integer", "Object", "Number", "All of the above compile"], answer: 0, hint: "Generics require reference types. Which of these is not a reference type?", explanation: "Generics cannot use primitive types. int is a primitive, so Box<int> does not compile. Integer, Object, and Number are all reference types and work correctly with autoboxing." },

  // oo7: exception handling - what goes in the catch
  { id: "oo7", topic: "OOP", question: "Which of the following could replace <code>&lt;1*&gt;</code> in the code to the right so that the code compiles?<pre><code>public static int parse(String s) {\n  try {\n    return Integer.parseInt(s);\n  } catch (&lt;1*&gt; e) {\n    return -1;\n  }\n}</code></pre>", choices: ["NumberFormatException", "Exception", "RuntimeException", "All of the above", "None of the above"], answer: 3, hint: "Integer.parseInt throws NumberFormatException. What types can catch it?", explanation: "NumberFormatException extends RuntimeException which extends Exception. Any of those three types can catch NumberFormatException. Therefore all of the above is correct." },

  // ══════════════════════════════════════════
  //  INHERITANCE / POLYMORPHISM OUTPUT TRACES (oo8 – oo14)
  // ══════════════════════════════════════════

  // oo8: constructor chaining with super
  { id: "oo8", topic: "OOP", question: "What is output by the code to the right?<pre><code>class A {\n  A() { out.print(\"A\"); }\n  A(int x) { out.print(\"A\" + x); }\n}\nclass B extends A {\n  B() { super(1); out.print(\"B\"); }\n}\nclass C extends B {\n  C() { out.print(\"C\"); }\n}\nnew C();</code></pre>", choices: ["A1BC", "CBA1", "ABC", "A1CB", "There is no output due to a compile error."], answer: 0, hint: "Constructors chain from topmost superclass down. C() implicitly calls B(), which explicitly calls A(1).", explanation: "new C() calls C(). C() implicitly calls B(). B() calls super(1) which invokes A(int). A(1) prints 'A1'. B() prints 'B'. C() prints 'C'. Output: A1BC." },

  // oo9: polymorphism - parent reference, child object
  { id: "oo9", topic: "OOP", question: "What is output by the code to the right?<pre><code>class Animal {\n  String speak() { return \"...\"; }\n}\nclass Dog extends Animal {\n  String speak() { return \"Woof\"; }\n}\nclass Cat extends Animal {\n  String speak() { return \"Meow\"; }\n}\nAnimal a = new Dog();\nAnimal b = new Cat();\nout.println(a.speak() + \" \" + b.speak());</code></pre>", choices: ["... ...", "Woof Meow", "... Meow", "Woof ...", "There is no output due to a compile error."], answer: 1, hint: "Polymorphism: the runtime type determines which overridden method is called.", explanation: "a's runtime type is Dog, so a.speak() returns 'Woof'. b's runtime type is Cat, so b.speak() returns 'Meow'. Output: Woof Meow." },

  // oo10: field hiding vs method overriding
  { id: "oo10", topic: "OOP", question: "What is output by the code to the right?<pre><code>class Parent {\n  int x = 10;\n  int getX() { return x; }\n}\nclass Child extends Parent {\n  int x = 20;\n  int getX() { return x; }\n}\nParent p = new Child();\nout.println(p.x + \" \" + p.getX());</code></pre>", choices: ["10 10", "20 20", "10 20", "20 10", "There is no output due to a compile error."], answer: 2, hint: "Fields are resolved by compile-time type (not polymorphic). Methods are resolved by runtime type.", explanation: "p.x uses the compile-time type Parent, so x = 10. p.getX() uses the runtime type Child, so getX() returns 20. Output: 10 20." },

  // oo11: super.method() call
  { id: "oo11", topic: "OOP", question: "What is output by the code to the right?<pre><code>class Base {\n  String name() { return \"Base\"; }\n}\nclass Sub extends Base {\n  String name() {\n    return super.name() + \"Sub\";\n  }\n}\nBase b = new Sub();\nout.println(b.name());</code></pre>", choices: ["Base", "Sub", "BaseSub", "SubBase", "There is no output due to a compile error."], answer: 2, hint: "super.name() calls the parent's version, then the result is concatenated with 'Sub'.", explanation: "b.name() calls Sub.name() (runtime type). Sub.name() calls super.name() which returns 'Base', then appends 'Sub'. Output: BaseSub." },

  // oo12: abstract class with constructor chaining
  { id: "oo12", topic: "OOP", question: "What is output by the code to the right?<pre><code>abstract class Instrument {\n  String type;\n  Instrument(String type) {\n    this.type = type;\n    out.print(type + \" \");\n  }\n  abstract void play();\n}\nclass Guitar extends Instrument {\n  Guitar() {\n    super(\"Guitar\");\n    out.print(\"ready \");\n  }\n  void play() { out.print(\"strum\"); }\n}\nGuitar g = new Guitar();\ng.play();</code></pre>", choices: ["Guitar ready strum", "strum", "ready strum", "Guitar strum", "There is no output due to a compile error."], answer: 0, hint: "Abstract classes can have constructors that run when a subclass is instantiated.", explanation: "new Guitar() calls super('Guitar') which prints 'Guitar '. Guitar() then prints 'ready '. g.play() prints 'strum'. Output: Guitar ready strum." },

  // oo13: interface polymorphism with array
  { id: "oo13", topic: "OOP", question: "What is output by the code to the right?<pre><code>interface Speakable {\n  String speak();\n}\nclass Duck implements Speakable {\n  public String speak() { return \"Quack\"; }\n}\nclass Cow implements Speakable {\n  public String speak() { return \"Moo\"; }\n}\nSpeakable[] farm = { new Duck(), new Cow(),\n                     new Duck() };\nString result = \"\";\nfor (Speakable s : farm)\n  result += s.speak().charAt(0);\nout.println(result);</code></pre>", choices: ["QMQ", "QuackMooQuack", "Quack", "DMD", "There is no output due to a compile error."], answer: 0, hint: "Each speak() returns a string. charAt(0) gets the first character of each.", explanation: "farm[0].speak()='Quack', charAt(0)='Q'. farm[1].speak()='Moo', charAt(0)='M'. farm[2].speak()='Quack', charAt(0)='Q'. result = 'QMQ'." },

  // oo14: casting - ClassCastException
  { id: "oo14", topic: "OOP", question: "What is output by the code to the right?<pre><code>class Fruit {}\nclass Apple extends Fruit {}\nclass Banana extends Fruit {}\nFruit f = new Apple();\nBanana b = (Banana) f;</code></pre>", choices: ["null", "No output; code compiles and runs fine", "There is no output due to a compile error.", "There is no output due to a ClassCastException.", "There is no output due to a NullPointerException."], answer: 3, hint: "f is actually an Apple at runtime. Can you cast an Apple to a Banana?", explanation: "f references an Apple. The cast (Banana) f compiles because both are Fruit subtypes, but at runtime Apple cannot be cast to Banana, so a ClassCastException is thrown." },

  // ══════════════════════════════════════════
  //  SHARED CODE BLOCK (oo15 – oo20)
  //  Builder pattern class — referenced by 6 questions
  // ══════════════════════════════════════════

  // oo15: shared code block + pattern identification
  { id: "oo15", topic: "OOP", question: "/* Use the code below to answer questions oo15 through oo20 */<pre><code>class Wizard {\n  private String name;\n  private int level;\n  private String spell;\n\n  private Wizard() {\n    name = \"Unknown\";\n    level = 1;\n    spell = \"Spark\";\n  }\n\n  public static Wizard create() {\n    return new Wizard();\n  }\n\n  public Wizard name(String n) {\n    this.name = n;\n    return this;\n  }\n\n  public Wizard level(int l) {\n    this.level = l;\n    return this;\n  }\n\n  public Wizard spell(String s) {\n    this.spell = s;\n    return this;\n  }\n\n  public String toString() {\n    return name + \" L\" + level\n           + \" [\" + spell + \"]\";\n  }\n}</code></pre>\nWhich design pattern does the <code>Wizard</code> class most closely demonstrate?", choices: ["Singleton", "Builder", "Observer", "Factory Method", "Adapter"], answer: 1, hint: "The class uses method chaining to set fields and returns the object itself from each setter.", explanation: "The Wizard class uses the Builder pattern: a private constructor, a static creation method, and setter methods that return 'this' to enable fluent method chaining." },

  // oo16: why is the constructor private?
  { id: "oo16", topic: "OOP", question: "Using the <code>Wizard</code> class from the previous question, why is the <code>Wizard()</code> constructor declared <code>private</code>?", choices: ["To prevent subclassing", "To force creation through the static create() method", "To make the class abstract", "To prevent any objects from being created", "To allow only one instance to exist"], answer: 1, hint: "A private constructor prevents direct instantiation with new Wizard() from outside the class.", explanation: "The private constructor forces callers to use Wizard.create() instead of new Wizard(). This is a common Builder/Factory pattern technique. It does not prevent all creation (create() still works) nor does it limit to one instance." },

  // oo17: what does each setter method return?
  { id: "oo17", topic: "OOP", question: "Using the <code>Wizard</code> class from question oo15, what does each setter method (<code>name</code>, <code>level</code>, <code>spell</code>) return?", choices: ["void", "A new Wizard object", "The value that was set", "A reference to the same Wizard object (this)", "null"], answer: 3, hint: "Look at the return statement in each setter. What does 'return this' give back?", explanation: "Each setter returns 'this', which is a reference to the same Wizard object. This enables method chaining: Wizard.create().name('X').level(5).spell('Fire')." },

  // oo18: method chaining output
  { id: "oo18", topic: "OOP", question: "Using the <code>Wizard</code> class from question oo15, what is output by the code to the right?<pre><code>Wizard w = Wizard.create()\n  .name(\"Gandalf\")\n  .level(99)\n  .spell(\"Fireball\");\nout.println(w);</code></pre>", choices: ["Unknown L1 [Spark]", "Gandalf L99 [Fireball]", "Wizard@1a2b3c", "Gandalf 99 Fireball", "There is no output due to a compile error."], answer: 1, hint: "Each chained method modifies the same Wizard object. println calls toString() on the object.", explanation: "Wizard.create() makes a Wizard with defaults. .name('Gandalf') sets name. .level(99) sets level. .spell('Fireball') sets spell. toString() returns 'Gandalf L99 [Fireball]'." },

  // oo19: default values from create() without chaining
  { id: "oo19", topic: "OOP", question: "Using the <code>Wizard</code> class from question oo15, what is output by the code to the right?<pre><code>Wizard w = Wizard.create();\nout.println(w);</code></pre>", choices: ["null L0 [null]", "Unknown L1 [Spark]", "There is no output due to a NullPointerException.", "Wizard@1a2b3c", "There is no output due to a compile error."], answer: 1, hint: "The private constructor sets default values for all three fields.", explanation: "Wizard.create() calls the private constructor which sets name='Unknown', level=1, spell='Spark'. toString() returns 'Unknown L1 [Spark]'." },

  // oo20: can you call new Wizard() directly?
  { id: "oo20", topic: "OOP", question: "Using the <code>Wizard</code> class from question oo15, what happens when the following code is compiled?<pre><code>Wizard w = new Wizard();</code></pre>(Assume this line is written outside the <code>Wizard</code> class.)", choices: ["It compiles and creates a Wizard with default values.", "It compiles but throws a RuntimeException.", "It does not compile because the constructor is private.", "It compiles but w is null.", "It does not compile because Wizard is abstract."], answer: 2, hint: "What access modifier is on the Wizard() constructor?", explanation: "The Wizard() constructor is private, so it cannot be called from outside the Wizard class. The code fails to compile. You must use Wizard.create() instead." },

  // ══════════════════════════════════════════
  //  CONCEPT IDENTIFICATION (oo21 – oo25)
  // ══════════════════════════════════════════

  // oo21: overloading vs overriding
  { id: "oo21", topic: "OOP", question: "Which OOP concept is demonstrated by the code to the right?<pre><code>class Printer {\n  void print(String s) {\n    out.println(s);\n  }\n  void print(int n) {\n    out.println(n);\n  }\n  void print(String s, int times) {\n    for (int i = 0; i &lt; times; i++)\n      out.println(s);\n  }\n}</code></pre>", choices: ["Overriding", "Overloading", "Encapsulation", "Abstraction", "Polymorphism"], answer: 1, hint: "Multiple methods with the same name but different parameter lists in the same class.", explanation: "Method overloading: the class defines multiple print methods with the same name but different parameter lists. Overriding requires a subclass redefining a parent method." },

  // oo22: encapsulation
  { id: "oo22", topic: "OOP", question: "Which OOP concept is demonstrated by the code to the right?<pre><code>class Student {\n  private String name;\n  private int grade;\n  public String getName() {\n    return name;\n  }\n  public void setGrade(int g) {\n    if (g >= 0 && g <= 100)\n      grade = g;\n  }\n}</code></pre>", choices: ["Overloading", "Inheritance", "Encapsulation", "Method Chaining", "Abstraction"], answer: 2, hint: "Private fields with public getters and setters that validate input.", explanation: "Encapsulation: the fields are private and accessed only through public methods that control and validate access. The setter prevents invalid grades." },

  // oo23: overriding
  { id: "oo23", topic: "OOP", question: "Which OOP concept is demonstrated by the code to the right?<pre><code>class Shape {\n  double area() { return 0; }\n}\nclass Rectangle extends Shape {\n  double w, h;\n  Rectangle(double w, double h) {\n    this.w = w;\n    this.h = h;\n  }\n  double area() { return w * h; }\n}</code></pre>", choices: ["Overloading", "Overriding", "Encapsulation", "Method Chaining", "Composition"], answer: 1, hint: "The subclass defines a method with the same signature as the parent class.", explanation: "Method overriding: Rectangle defines area() with the exact same signature as Shape's area(), replacing the parent's behavior in subclass instances." },

  // oo24: method chaining (fluent interface)
  { id: "oo24", topic: "OOP", question: "Which OOP concept is demonstrated by the code to the right?<pre><code>class Query {\n  String table;\n  String condition;\n  Query from(String t) {\n    table = t;\n    return this;\n  }\n  Query where(String c) {\n    condition = c;\n    return this;\n  }\n}\nQuery q = new Query()\n  .from(\"users\")\n  .where(\"age > 18\");</code></pre>", choices: ["Overloading", "Overriding", "Encapsulation", "Method Chaining", "Inheritance"], answer: 3, hint: "Each method returns 'this', allowing calls to be linked together in one expression.", explanation: "Method chaining (fluent interface): each method returns 'this' so that multiple method calls can be chained in a single statement." },

  // oo25: abstraction (abstract class + interface)
  { id: "oo25", topic: "OOP", question: "Which OOP concept is <em>primarily</em> demonstrated by the code to the right?<pre><code>abstract class DatabaseDriver {\n  abstract void connect(String url);\n  abstract void query(String sql);\n  void close() {\n    out.println(\"Connection closed.\");\n  }\n}</code></pre>", choices: ["Overloading", "Overriding", "Encapsulation", "Abstraction", "Method Chaining"], answer: 3, hint: "The class defines what must be done (connect, query) without specifying how.", explanation: "Abstraction: the abstract class defines a contract (connect and query must be implemented) while hiding implementation details. Subclasses provide the specific behavior." },
];
