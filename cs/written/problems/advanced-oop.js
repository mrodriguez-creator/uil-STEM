// UIL Computer Science – Advanced OOP
// Covers: static/instance initializer blocks, inner/nested classes, generics wildcards,
// linked list code reading, enum types, protected access & final keyword edge cases
// Uses out.print / out.println (UIL static import convention)
const ADVANCED_OOP_PROBLEMS = [

  // ══════════════════════════════════════════════════════════
  //  A) STATIC & INSTANCE INITIALIZER BLOCKS (ao1 – ao6)
  //     Shared code block — 6 questions on one class
  // ══════════════════════════════════════════════════════════

  // ao1: full shared code block + first object creation
  { id: "ao1", topic: "Advanced OOP", question: "/* Use the code below to answer questions ao1 through ao6 */<pre><code>class Widget {\n  static int count = 0;\n\n  static {\n    count += 10;\n    out.print(\"S \");\n  }\n\n  {\n    count++;\n    out.print(\"I \");\n  }\n\n  Widget() {\n    out.print(\"C\" + count + \" \");\n  }\n\n  Widget(String label) {\n    this();\n    out.print(label + \" \");\n  }\n}</code></pre>\nWhat is output when the following line executes in a program that has not yet referenced the <code>Widget</code> class?<pre><code>Widget w1 = new Widget();</code></pre>", choices: ["I C1 S", "S I C11", "S C11 I", "I S C11", "There is no output due to a compile error."], answer: 1, hint: "Static initializer blocks run once when the class is first loaded — before instance blocks and constructors.", explanation: "Class first loaded: static block runs, count becomes 10, prints 'S '. Then instance block: count becomes 11, prints 'I '. Then constructor: prints 'C' + count which is 'C11'. Output: S I C11." },

  // ao2: second object creation — static block does NOT run again
  { id: "ao2", topic: "Advanced OOP", question: "Using the <code>Widget</code> class from question ao1, assume <code>w1</code> has already been created. What <em>additional</em> output is produced by:<pre><code>Widget w2 = new Widget();</code></pre>", choices: ["S I C12", "I C12", "S I C11", "I C11", "There is no output due to a compile error."], answer: 1, hint: "The static block has already run. Does it run again for a second object?", explanation: "Static blocks run only once when the class is first loaded. For w2, only the instance block and constructor execute. Instance block: count goes from 11 to 12, prints 'I '. Constructor: prints 'C12 '. Additional output: I C12." },

  // ao3: order of execution
  { id: "ao3", topic: "Advanced OOP", question: "Using the <code>Widget</code> class from question ao1, what is the correct order of execution when the <em>first</em> <code>Widget</code> object is created?", choices: ["Constructor, then instance block, then static block", "Instance block, then static block, then constructor", "Static block, then constructor, then instance block", "Static block, then instance block, then constructor", "Instance block, then constructor, then static block"], answer: 3, hint: "Static initialization happens at class loading time, before any objects exist.", explanation: "When the first object is created: (1) class is loaded, static block runs, (2) instance initializer block runs, (3) constructor body runs. Order: static block -> instance block -> constructor." },

  // ao4: accessing a static field without creating an object
  { id: "ao4", topic: "Advanced OOP", question: "Using the <code>Widget</code> class from question ao1, assume the class has never been referenced. What is output by:<pre><code>out.println(Widget.count);</code></pre>", choices: ["0", "S 10", "S 0", "10", "There is no output due to a compile error."], answer: 1, hint: "Accessing a static field causes the class to load. Does the static block run? Does the instance block run?", explanation: "Accessing Widget.count loads the class, triggering the static block: count becomes 10, prints 'S '. No object is created, so the instance block does NOT run. Then out.println prints 10. Output: S 10." },

  // ao5: inheritance with both static and instance initializers
  { id: "ao5", topic: "Advanced OOP", question: "Using the <code>Widget</code> class from question ao1, assume neither class has been loaded yet. What is output by the code to the right?<pre><code>class Gadget extends Widget {\n  static { out.print(\"GS \"); }\n  { out.print(\"GI \"); }\n  Gadget() { out.print(\"GC \"); }\n}\nnew Gadget();</code></pre>", choices: ["S GS I GI C11 GC", "GS S GI I GC C11", "S I C11 GS GI GC", "S GS I C11 GI GC", "There is no output due to a compile error."], answer: 3, hint: "Parent class loads first (static blocks), then child's static block. Then parent instance block + constructor, then child instance block + constructor.", explanation: "Class loading: Widget's static block prints 'S ', then Gadget's static block prints 'GS '. Object creation: Widget's instance block runs (count 10->11), prints 'I '. Widget's constructor prints 'C11 '. Gadget's instance block prints 'GI '. Gadget's constructor prints 'GC '. Output: S GS I C11 GI GC." },

  // ao6: concept question about initializer blocks
  { id: "ao6", topic: "Advanced OOP", question: "Using the <code>Widget</code> class from question ao1, which statement about initializer blocks is <strong>TRUE</strong>?", choices: ["A static initializer block runs each time an object is created.", "An instance initializer block runs before the static initializer block.", "A class may have at most one static initializer block.", "An instance initializer block can assign values to instance fields.", "Static initializer blocks can access instance fields directly."], answer: 3, hint: "Think about what 'instance' and 'static' contexts can access.", explanation: "Instance initializer blocks execute in the context of an object, so they can assign to instance fields (as shown by count++ in Widget). Choice A is false (static runs once). Choice B is false (static runs first). Choice C is false (multiple are allowed). Choice E is false (static context cannot access instance members)." },

  // ══════════════════════════════════════════════════════════
  //  B) STATIC INNER / NESTED CLASSES (ao7 – ao10)
  // ══════════════════════════════════════════════════════════

  // ao7: static nested class instantiation
  { id: "ao7", topic: "Advanced OOP", question: "What is output by the code to the right?<pre><code>class Outer {\n  static int x = 5;\n  int y = 10;\n\n  static class Nested {\n    void show() {\n      out.println(\"x=\" + x);\n    }\n  }\n}\nOuter.Nested n = new Outer.Nested();\nn.show();</code></pre>", choices: ["x=5", "x=10", "There is no output due to a compile error.", "There is no output due to a runtime error.", "x=0"], answer: 0, hint: "A static nested class can be instantiated without an Outer instance. Can it access Outer's static members?", explanation: "A static nested class can access the enclosing class's static members. Outer.Nested is created with new Outer.Nested(). show() accesses static x = 5. Output: x=5." },

  // ao8: static nested class accessing instance member — compile error
  { id: "ao8", topic: "Advanced OOP", question: "What is output by the code to the right?<pre><code>class Outer {\n  static int x = 5;\n  int y = 10;\n\n  static class Nested {\n    void show() {\n      out.println(\"y=\" + y);\n    }\n  }\n}\nOuter.Nested n = new Outer.Nested();\nn.show();</code></pre>", choices: ["y=10", "y=0", "y=5", "There is no output due to a compile error.", "There is no output due to a runtime error."], answer: 3, hint: "A static nested class does not have an implicit reference to an Outer instance.", explanation: "A static nested class cannot access non-static (instance) members of the enclosing class because it has no implicit reference to an Outer object. Accessing y causes a compile error." },

  // ao9: non-static inner class instantiation syntax
  { id: "ao9", topic: "Advanced OOP", question: "What is output by the code to the right?<pre><code>class Outer {\n  int val = 42;\n\n  class Inner {\n    void show() {\n      out.println(val);\n    }\n  }\n}\nOuter outer = new Outer();\nOuter.Inner in = outer.new Inner();\nin.show();</code></pre>", choices: ["42", "0", "null", "There is no output due to a compile error.", "There is no output due to a runtime error."], answer: 0, hint: "A non-static inner class requires an enclosing instance. The syntax outer.new Inner() provides it.", explanation: "A non-static inner class is instantiated via outer.new Inner(), which ties it to the Outer instance. show() accesses val = 42 from the enclosing instance. Output: 42." },

  // ao10: wrong instantiation syntax for inner class
  { id: "ao10", topic: "Advanced OOP", question: "What is output by the code to the right?<pre><code>class Outer {\n  int val = 42;\n\n  class Inner {\n    void show() {\n      out.println(val);\n    }\n  }\n}\nOuter.Inner in = new Outer.Inner();\nin.show();</code></pre>", choices: ["42", "0", "null", "There is no output due to a compile error.", "There is no output due to a runtime error."], answer: 3, hint: "Non-static inner classes require an enclosing instance. Can you create one with new Outer.Inner()?", explanation: "A non-static inner class cannot be instantiated with new Outer.Inner() because it requires an enclosing Outer instance. The correct syntax is outer.new Inner(). This code fails to compile." },

  // ══════════════════════════════════════════════════════════
  //  C) GENERICS WILDCARDS (ao11 – ao14)
  // ══════════════════════════════════════════════════════════

  // ao11: upper bounded wildcard
  { id: "ao11", topic: "Advanced OOP", question: "Which of the following method signatures allows the method to accept a <code>List&lt;Integer&gt;</code>, a <code>List&lt;Double&gt;</code>, and a <code>List&lt;Number&gt;</code>, but <strong>NOT</strong> a <code>List&lt;String&gt;</code>?", choices: ["void process(List<?> list)", "void process(List<Object> list)", "void process(List<? extends Number> list)", "void process(List<? super Number> list)", "void process(List<Number> list)"], answer: 2, hint: "Integer and Double extend Number. String does not. Which wildcard restricts to subtypes of Number?", explanation: "List<? extends Number> accepts any List whose type parameter is Number or a subclass of Number. Integer and Double extend Number, so they are accepted. String does not extend Number, so it is rejected. Choice A accepts anything. Choice B accepts only List<Object>. Choice E accepts only List<Number>." },

  // ao12: which compiles?
  { id: "ao12", topic: "Advanced OOP", question: "Given the declaration below, which statement compiles?<pre><code>List&lt;? extends Number&gt; nums =\n    new ArrayList&lt;Integer&gt;();</code></pre>", choices: ["nums.add(42);", "nums.add(3.14);", "Number n = nums.get(0);", "nums.add(null);", "Both C and D"], answer: 4, hint: "With <? extends Number>, the compiler doesn't know the actual type, so it restricts what you can add.", explanation: "With <? extends Number>, you cannot add any non-null element because the compiler cannot guarantee type safety (the list could be List<Integer> or List<Double>). You CAN read elements as Number (choice C). You CAN add null (choice D, null is compatible with any reference type). Both C and D compile." },

  // ao13: lower bounded wildcard
  { id: "ao13", topic: "Advanced OOP", question: "Given the declaration below, which statement does <strong>NOT</strong> compile?<pre><code>List&lt;? super Integer&gt; list =\n    new ArrayList&lt;Number&gt;();</code></pre>", choices: ["list.add(42);", "list.add(new Integer(7));", "Integer val = list.get(0);", "Object obj = list.get(0);", "list.add(100);"], answer: 2, hint: "With <? super Integer>, you can safely add Integer values, but what type do you get back when reading?", explanation: "With <? super Integer>, the list could be List<Integer>, List<Number>, or List<Object>. You can add Integer (and its subtypes) safely. But when reading, the compiler only guarantees Object, not Integer. Choice C tries to assign to Integer without a cast, which does not compile. Choice D compiles because Object is always safe." },

  // ao14: bounded type parameter with Comparable
  { id: "ao14", topic: "Advanced OOP", question: "What is output by the code to the right?<pre><code>public static &lt;T extends Comparable&lt;T&gt;&gt;\n    T findMax(T a, T b) {\n  return a.compareTo(b) >= 0 ? a : b;\n}\n//client code:\nout.println(findMax(\"apple\", \"banana\"));\nout.println(findMax(10, 5));</code></pre>", choices: ["banana\\n10", "apple\\n5", "apple\\n10", "There is no output due to a compile error.", "There is no output due to a runtime error."], answer: 0, hint: "String's compareTo uses lexicographic order. Integer's compareTo uses numeric order.", explanation: "findMax(\"apple\", \"banana\"): \"apple\".compareTo(\"banana\") is negative (a < b lexicographically), so returns \"banana\". findMax(10, 5): 10.compareTo(5) is positive, so returns 10. Output: banana then 10." },

  // ══════════════════════════════════════════════════════════
  //  D) LINKED LIST IMPLEMENTATION CODE READING (ao15 – ao20)
  //     Shared code block — 6 questions on one implementation
  // ══════════════════════════════════════════════════════════

  // ao15: full shared code block + ADT identification
  { id: "ao15", topic: "Advanced OOP", question: "/* Use the code below to answer questions ao15 through ao20 */<pre><code>class Node&lt;T&gt; {\n  T data;\n  Node&lt;T&gt; next;\n  Node(T d) { data = d; next = null; }\n}\nclass MyList&lt;T&gt; {\n  Node&lt;T&gt; head;\n  int size;\n  MyList() { head = null; size = 0; }\n\n  void addFront(T val) {\n    Node&lt;T&gt; n = new Node&lt;&gt;(val);\n    n.next = head;\n    head = n;\n    size++;\n  }\n  void addBack(T val) {\n    Node&lt;T&gt; n = new Node&lt;&gt;(val);\n    if(head == null) { head = n; }\n    else {\n      Node&lt;T&gt; cur = head;\n      while(cur.next != null)\n        cur = cur.next;\n      cur.next = n;\n    }\n    size++;\n  }\n  T removeFront() {\n    if(head == null)\n      throw new RuntimeException(\"empty\");\n    T val = head.data;\n    head = head.next;\n    size--;\n    return val;\n  }\n  public String toString() {\n    String s = \"[\";\n    Node&lt;T&gt; cur = head;\n    while(cur != null) {\n      s += cur.data;\n      if(cur.next != null) s += \", \";\n      cur = cur.next;\n    }\n    return s + \"]\";\n  }\n}</code></pre>\nWhat abstract data type does <code>MyList</code> with only <code>addFront</code> and <code>removeFront</code> most closely represent?", choices: ["Queue", "Stack", "Deque", "Priority Queue", "Set"], answer: 1, hint: "addFront adds to the front, removeFront removes from the front. What ADT uses the same end for both add and remove?", explanation: "Adding and removing from the same end (front) is LIFO — Last In, First Out — which is a Stack. A Queue uses opposite ends (add back, remove front). A Deque supports both ends." },

  // ao16: trace addFront/addBack and toString
  { id: "ao16", topic: "Advanced OOP", question: "Using the <code>MyList</code> class from question ao15, what is output by the code to the right?<pre><code>MyList&lt;String&gt; m = new MyList&lt;&gt;();\nm.addBack(\"A\");\nm.addBack(\"B\");\nm.addFront(\"C\");\nm.addBack(\"D\");\nm.addFront(\"E\");\nout.println(m);</code></pre>", choices: ["[A, B, C, D, E]", "[E, C, A, B, D]", "[C, E, A, B, D]", "[E, C, D, A, B]", "[D, C, E, A, B]"], answer: 1, hint: "Trace each operation: addBack appends to the end, addFront inserts at the beginning.", explanation: "Start: []. addBack(A): [A]. addBack(B): [A, B]. addFront(C): [C, A, B]. addBack(D): [C, A, B, D]. addFront(E): [E, C, A, B, D]. Output: [E, C, A, B, D]." },

  // ao17: trace removeFront operations
  { id: "ao17", topic: "Advanced OOP", question: "Using the <code>MyList</code> class from question ao15, what is output by the code to the right?<pre><code>MyList&lt;Integer&gt; m = new MyList&lt;&gt;();\nm.addBack(10);\nm.addBack(20);\nm.addBack(30);\nm.addFront(5);\nout.print(m.removeFront() + \" \");\nout.print(m.removeFront() + \" \");\nout.println(m);</code></pre>", choices: ["5 10 [30, 20]", "10 20 [5, 30]", "5 10 [20, 30]", "30 20 [5, 10]", "There is no output due to a runtime error."], answer: 2, hint: "After adds, list is [5, 10, 20, 30]. removeFront returns and removes the first element.", explanation: "addBack(10): [10]. addBack(20): [10, 20]. addBack(30): [10, 20, 30]. addFront(5): [5, 10, 20, 30]. removeFront(): returns 5, list becomes [10, 20, 30]. removeFront(): returns 10, list becomes [20, 30]. Output: 5 10 [20, 30]." },

  // ao18: removeFront from empty list — runtime error
  { id: "ao18", topic: "Advanced OOP", question: "Using the <code>MyList</code> class from question ao15, what is output by the code to the right?<pre><code>MyList&lt;Integer&gt; m = new MyList&lt;&gt;();\nm.addBack(1);\nm.removeFront();\nm.removeFront();</code></pre>", choices: ["1", "null", "0", "There is no output due to a compile error.", "There is no output due to a runtime error."], answer: 4, hint: "After adding 1 and removing it, the list is empty. What does removeFront do when head is null?", explanation: "addBack(1): [1]. First removeFront(): returns 1, list is []. Second removeFront(): head is null, so it throws RuntimeException(\"empty\"). Runtime error." },

  // ao19: time complexity question
  { id: "ao19", topic: "Advanced OOP", question: "Using the <code>MyList</code> class from question ao15, what are the asymptotic time complexities of <code>addFront()</code> and <code>addBack()</code>, respectively, where <code>n</code> is the current size of the list?", choices: ["O(1) and O(1)", "O(n) and O(n)", "O(1) and O(n)", "O(n) and O(1)", "O(log n) and O(n)"], answer: 2, hint: "addFront creates a node and updates head. addBack must traverse to the last node.", explanation: "addFront: creates a new node, sets its next to head, updates head. All O(1) operations. addBack: if the list is not empty, traverses from head to the last node (O(n)), then appends. So addFront is O(1), addBack is O(n)." },

  // ao20: describe what a method does
  { id: "ao20", topic: "Advanced OOP", question: "Using the <code>MyList</code> class from question ao15, consider adding the following method to <code>MyList</code>:<pre><code>T mystery() {\n  if(head == null) return null;\n  if(head.next == null) {\n    T val = head.data;\n    head = null;\n    size--;\n    return val;\n  }\n  Node&lt;T&gt; cur = head;\n  while(cur.next.next != null)\n    cur = cur.next;\n  T val = cur.next.data;\n  cur.next = null;\n  size--;\n  return val;\n}</code></pre>\nWhat does <code>mystery()</code> do?", choices: ["Removes and returns the front element", "Removes and returns the last element", "Returns the last element without removing it", "Reverses the list and returns the new head", "Returns null if the list has more than one element"], answer: 1, hint: "The method traverses to the second-to-last node, saves the last node's data, and removes it.", explanation: "If empty, returns null. If one element, removes and returns it. Otherwise, traverses until cur.next.next is null (cur is second-to-last), saves cur.next.data, sets cur.next to null (removes last node), decrements size. This removes and returns the last element." },

  // ══════════════════════════════════════════════════════════
  //  E) ENUM TYPES (ao21 – ao23)
  // ══════════════════════════════════════════════════════════

  // ao21: basic enum usage and ordinal
  { id: "ao21", topic: "Advanced OOP", question: "What is output by the code to the right?<pre><code>enum Season {\n  SPRING, SUMMER, FALL, WINTER\n}\nSeason s = Season.FALL;\nout.println(s.ordinal()\n    + \" \" + s.name());</code></pre>", choices: ["3 FALL", "2 FALL", "2 Fall", "3 Fall", "There is no output due to a compile error."], answer: 1, hint: "ordinal() returns the zero-based position. name() returns the exact constant name.", explanation: "Enum constants are zero-indexed: SPRING=0, SUMMER=1, FALL=2, WINTER=3. s.ordinal() = 2. s.name() = \"FALL\" (exact declared name). Output: 2 FALL." },

  // ao22: enum with fields and constructor
  { id: "ao22", topic: "Advanced OOP", question: "What is output by the code to the right?<pre><code>enum Coin {\n  PENNY(1), NICKEL(5),\n  DIME(10), QUARTER(25);\n\n  private int cents;\n  Coin(int c) { cents = c; }\n  int getCents() { return cents; }\n}\nint total = 0;\nfor(Coin c : Coin.values())\n  total += c.getCents();\nout.println(total);</code></pre>", choices: ["4", "10", "41", "100", "There is no output due to a compile error."], answer: 2, hint: "Coin.values() returns all enum constants. Sum their cents: 1 + 5 + 10 + 25.", explanation: "Coin.values() returns [PENNY, NICKEL, DIME, QUARTER]. Sum: 1 + 5 + 10 + 25 = 41. Output: 41." },

  // ao23: switch on enum
  { id: "ao23", topic: "Advanced OOP", question: "What is output by the code to the right?<pre><code>enum Day {\n  MON, TUE, WED, THU, FRI, SAT, SUN\n}\nDay d = Day.WED;\nString type;\nswitch(d) {\n  case MON: case TUE: case WED:\n  case THU: case FRI:\n    type = \"Weekday\";\n    break;\n  case SAT: case SUN:\n    type = \"Weekend\";\n    break;\n  default:\n    type = \"Unknown\";\n}\nout.println(type);</code></pre>", choices: ["Weekday", "Weekend", "Unknown", "WED", "There is no output due to a compile error."], answer: 0, hint: "d is WED. The switch falls through MON, TUE, WED to the Weekday assignment.", explanation: "d = WED matches case WED, which falls through to the block that assigns type = \"Weekday\" and breaks. Output: Weekday." },

  // ══════════════════════════════════════════════════════════
  //  F) PROTECTED ACCESS & FINAL KEYWORD EDGE CASES (ao24 – ao25)
  // ══════════════════════════════════════════════════════════

  // ao24: access modifier knowledge
  { id: "ao24", topic: "Advanced OOP", question: "Which access modifier allows a member to be accessed by subclasses in a <em>different</em> package, but <strong>NOT</strong> by non-subclass classes in that different package?", choices: ["public", "private", "default (package-private)", "protected", "final"], answer: 3, hint: "This modifier grants access to the same package AND to subclasses, even in other packages.", explanation: "protected allows access within the same package and by subclasses in any package. Non-subclass classes in a different package cannot access protected members. public allows all access. private allows only same-class. Default (no modifier) allows only same-package. final is not an access modifier." },

  // ao25: abstract and final together
  { id: "ao25", topic: "Advanced OOP", question: "Which of the following statements about <code>abstract</code> and <code>final</code> in Java is <strong>TRUE</strong>?", choices: ["A class can be both abstract and final.", "An abstract class can contain final methods.", "A final class can contain abstract methods.", "An abstract method can be declared final.", "None of the above are true."], answer: 1, hint: "Think about what abstract and final each mean for classes and methods, and whether they conflict.", explanation: "An abstract class CAN have final methods — the final method provides a concrete implementation that subclasses cannot override. Choice A is false: a final class cannot be extended, but an abstract class must be extended. Choice C is false: a final class cannot be extended, so abstract methods could never be implemented. Choice D is false: a final method cannot be overridden, but an abstract method must be overridden — contradiction." },

];
