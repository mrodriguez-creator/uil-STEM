// UIL CS Written Test – Collections API
const COLLECTIONS_PROBLEMS = [

  { id: "co1", topic: "Collections API", difficulty: 1, question: "Which interface does <code>ArrayList</code> implement?", choices: ["<code>Set</code>", "<code>Map</code>", "<code>List</code>", "<code>Queue</code>", "<code>Stack</code>"], answer: 2, hint: "ArrayList maintains an ordered, indexed collection", explanation: "ArrayList implements the List interface (which extends Collection)." },
  { id: "co2", topic: "Collections API", difficulty: 1, question: "Which collection does NOT allow duplicate elements?", choices: ["<code>ArrayList</code>", "<code>LinkedList</code>", "<code>HashSet</code>", "<code>Stack</code>", "<code>Queue</code>"], answer: 2, hint: "Sets enforce uniqueness", explanation: "HashSet implements Set, which does not allow duplicate elements." },
  { id: "co3", topic: "Collections API", difficulty: 2, question: "Which collection maintains elements in sorted order?", choices: ["<code>HashSet</code>", "<code>HashMap</code>", "<code>ArrayList</code>", "<code>TreeSet</code>", "<code>LinkedList</code>"], answer: 3, hint: "One of the Set implementations keeps elements sorted", explanation: "TreeSet maintains elements in natural sorted order (or by a Comparator)." },
  { id: "co4", topic: "Collections API", difficulty: 2, question: "Which method adds an element to an <code>ArrayList</code>?", choices: ["<code>push()</code>", "<code>insert()</code>", "<code>add()</code>", "<code>append()</code>", "<code>put()</code>"], answer: 2, hint: "This is the standard List method for appending", explanation: "ArrayList uses add(element) to append an element." },
  { id: "co5", topic: "Collections API", difficulty: 2, question: "Which method is used to add a key-value pair to a <code>HashMap</code>?", choices: ["<code>add()</code>", "<code>insert()</code>", "<code>put()</code>", "<code>set()</code>", "<code>push()</code>"], answer: 2, hint: "Maps use a different method name than Lists", explanation: "HashMap uses put(key, value) to add or update entries." },
  { id: "co6", topic: "Collections API", difficulty: 2, question: "What does <code>Stack.peek()</code> do?", choices: ["Removes and returns the top element", "Returns the top element without removing it", "Returns the bottom element", "Returns <code>true</code> if the stack is empty", "Adds an element to the top"], answer: 1, hint: "peek looks at the top without modifying the stack", explanation: "peek() returns the top element without removing it." },
  { id: "co7", topic: "Collections API", difficulty: 2, question: "What does <code>Stack.pop()</code> do?", choices: ["Returns the top element without removing", "Removes and returns the top element", "Removes the bottom element", "Adds an element", "Returns the stack size"], answer: 1, hint: "pop removes the most recently added element", explanation: "pop() removes and returns the top element of the stack." },
  { id: "co8", topic: "Collections API", difficulty: 2, question: "In a <code>Queue</code>, which method adds an element?", choices: ["<code>push()</code>", "<code>add()</code> or <code>offer()</code>", "<code>put()</code>", "<code>enqueue()</code>", "<code>insert()</code>"], answer: 1, hint: "Queue has two methods for adding: one throws, one returns false", explanation: "Queue uses add() (throws exception if full) or offer() (returns false if full)." },
  { id: "co9", topic: "Collections API", difficulty: 2, question: "In a <code>Queue</code>, which method removes and returns the head?", choices: ["<code>pop()</code>", "<code>remove()</code> or <code>poll()</code>", "<code>get()</code>", "<code>dequeue()</code>", "<code>take()</code>"], answer: 1, hint: "Queue has two methods for removing: one throws, one returns null", explanation: "Queue uses remove() (throws exception if empty) or poll() (returns null if empty)." },
  { id: "co10", topic: "Collections API", difficulty: 3, question: "Which of the following is true about <code>HashMap</code>?", choices: ["Keys are stored in sorted order", "Duplicate keys are allowed", "It implements the <code>List</code> interface", "Keys must be unique", "It maintains insertion order"], answer: 3, hint: "Maps associate unique keys with values", explanation: "HashMap requires unique keys. Duplicate keys overwrite the previous value." },
  { id: "co11", topic: "Collections API", difficulty: 3, question: "Which collection should you use for FIFO (first-in, first-out) behavior?", choices: ["<code>Stack</code>", "<code>ArrayList</code>", "<code>Queue</code> / <code>LinkedList</code>", "<code>HashSet</code>", "<code>TreeMap</code>"], answer: 2, hint: "FIFO means the first element added is the first removed", explanation: "Queue provides FIFO behavior. LinkedList implements Queue." },
  { id: "co12", topic: "Collections API", difficulty: 3, question: "Which collection should you use for LIFO (last-in, first-out) behavior?", choices: ["<code>Queue</code>", "<code>ArrayList</code>", "<code>Stack</code>", "<code>HashSet</code>", "<code>TreeSet</code>"], answer: 2, hint: "LIFO means the last element added is the first removed", explanation: "Stack provides LIFO behavior with push() and pop()." },
  { id: "co13", topic: "Collections API", difficulty: 2, question: "What does <code>ArrayList.get(0)</code> return?", choices: ["The last element", "The first element", "The size of the list", "A boolean", "Compile error"], answer: 1, hint: "get() retrieves by index, and indices start at 0", explanation: "get(0) returns the first element (0-based indexing)." },
  { id: "co14", topic: "Collections API", difficulty: 3, question: "What is the time complexity of <code>ArrayList.get(i)</code>?", choices: ["O(1)", "O(log n)", "O(n)", "O(n log n)", "O(n²)"], answer: 0, hint: "ArrayList is backed by an array — direct index access", explanation: "ArrayList uses an internal array, so get(i) is O(1) random access." },
  { id: "co15", topic: "Collections API", difficulty: 3, question: "What is the time complexity of <code>LinkedList.get(i)</code>?", choices: ["O(1)", "O(log n)", "O(n)", "O(n log n)", "O(n²)"], answer: 2, hint: "LinkedList must traverse nodes to reach index i", explanation: "LinkedList has no random access — it must walk from the head, so get(i) is O(n)." },
];
