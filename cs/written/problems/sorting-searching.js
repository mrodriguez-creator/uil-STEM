// UIL CS Written Test – Sorting & Searching Algorithms
const SORTING_SEARCHING_PROBLEMS = [

  { id: "ss1", topic: "Sorting & Searching", difficulty: 1, question: "Which search algorithm requires the array to be sorted?", choices: ["Linear search", "Binary search", "Both", "Neither", "It depends on the data"], answer: 1, hint: "One of these divides the search space in half", explanation: "Binary search requires a sorted array. Linear search works on any array." },
  { id: "ss2", topic: "Sorting & Searching", difficulty: 2, question: "How many comparisons does binary search need in the worst case for an array of 1024 elements?", choices: ["10", "11", "32", "512", "1024"], answer: 0, hint: "log₂(1024) = ?", explanation: "log₂(1024) = 10 comparisons in the worst case." },
  { id: "ss3", topic: "Sorting & Searching", difficulty: 2, question: "Which sorting algorithm repeatedly finds the minimum element and places it at the front?", choices: ["Bubble sort", "Insertion sort", "Selection sort", "Merge sort", "Quicksort"], answer: 2, hint: "It 'selects' the smallest remaining element each pass", explanation: "Selection sort finds the minimum in the unsorted portion and swaps it into position." },
  { id: "ss4", topic: "Sorting & Searching", difficulty: 2, question: "Which sorting algorithm builds the sorted array one element at a time by inserting each element into its correct position?", choices: ["Bubble sort", "Insertion sort", "Selection sort", "Merge sort", "Radix sort"], answer: 1, hint: "Think of sorting a hand of cards", explanation: "Insertion sort inserts each element into its correct position in the already-sorted portion." },
  { id: "ss5", topic: "Sorting & Searching", difficulty: 2, question: "Which sorting algorithm uses a divide-and-conquer strategy and always runs in O(n log n)?", choices: ["Bubble sort", "Insertion sort", "Selection sort", "Merge sort", "Quicksort"], answer: 3, hint: "It divides the array in half, sorts each half, then merges", explanation: "Merge sort always runs in O(n log n), regardless of input order." },
  { id: "ss6", topic: "Sorting & Searching", difficulty: 2, question: "Is selection sort a stable sorting algorithm?", choices: ["Yes, always", "No, never", "Only for integer arrays", "Only with a special implementation", "It depends on the data"], answer: 1, hint: "Stability means equal elements maintain their relative order", explanation: "Selection sort is NOT stable — swapping can change the relative order of equal elements." },
  { id: "ss7", topic: "Sorting & Searching", difficulty: 2, question: "Is insertion sort a stable sorting algorithm?", choices: ["Yes", "No", "Only for small arrays", "Only for nearly sorted arrays", "Depends on implementation"], answer: 0, hint: "Equal elements are never swapped past each other", explanation: "Insertion sort is stable — it only moves elements when strictly necessary, preserving order of equals." },
  { id: "ss8", topic: "Sorting & Searching", difficulty: 3, question: "What is the best-case time complexity of insertion sort?", choices: ["O(1)", "O(log n)", "O(n)", "O(n log n)", "O(n²)"], answer: 2, hint: "What happens when the array is already sorted?", explanation: "Best case is O(n) — when the array is already sorted, each element requires only one comparison." },
  { id: "ss9", topic: "Sorting & Searching", difficulty: 2, question: "What is the worst-case time complexity of bubble sort?", choices: ["O(n)", "O(n log n)", "O(n²)", "O(n³)", "O(2ⁿ)"], answer: 2, hint: "In the worst case, every pair must be compared", explanation: "Bubble sort is O(n²) in the worst case (reverse-sorted array)." },
  { id: "ss10", topic: "Sorting & Searching", difficulty: 3, question: "Quicksort uses which strategy?", choices: ["Divide and conquer", "Greedy", "Dynamic programming", "Brute force", "Backtracking"], answer: 0, hint: "It partitions the array around a pivot, then recursively sorts each part", explanation: "Quicksort uses divide and conquer: partition around a pivot, then sort each side." },
  { id: "ss11", topic: "Sorting & Searching", difficulty: 3, question: "Which sorting algorithm does NOT use comparisons between elements?", choices: ["Merge sort", "Quicksort", "Insertion sort", "Radix sort", "Selection sort"], answer: 3, hint: "This sort uses digit-by-digit processing", explanation: "Radix sort sorts by processing digits/characters — it's a non-comparison sort." },
  { id: "ss12", topic: "Sorting & Searching", difficulty: 3, question: "After one complete pass of selection sort on <code>[5, 3, 8, 1, 4]</code>, the array becomes:", choices: ["<code>[1, 3, 8, 5, 4]</code>", "<code>[1, 5, 3, 8, 4]</code>", "<code>[3, 5, 1, 4, 8]</code>", "<code>[1, 3, 5, 4, 8]</code>", "<code>[3, 5, 8, 1, 4]</code>"], answer: 0, hint: "Selection sort finds the minimum and swaps it with the first position", explanation: "Minimum is 1 (at index 3). Swap with index 0: [1, 3, 8, 5, 4]." },
  { id: "ss13", topic: "Sorting & Searching", difficulty: 3, question: "After one complete pass of bubble sort on <code>[5, 3, 8, 1, 4]</code>, the array becomes:", choices: ["<code>[3, 5, 1, 4, 8]</code>", "<code>[1, 3, 4, 5, 8]</code>", "<code>[3, 5, 8, 1, 4]</code>", "<code>[5, 3, 1, 4, 8]</code>", "<code>[1, 3, 5, 4, 8]</code>"], answer: 0, hint: "Bubble sort compares adjacent pairs and swaps if out of order, left to right", explanation: "5>3 swap [3,5,8,1,4]; 5<8 no swap; 8>1 swap [3,5,1,8,4]; 8>4 swap [3,5,1,4,8]. Result: [3,5,1,4,8]." },
  { id: "ss14", topic: "Sorting & Searching", difficulty: 2, question: "What is the space complexity of selection sort?", choices: ["O(1)", "O(log n)", "O(n)", "O(n log n)", "O(n²)"], answer: 0, hint: "Selection sort sorts in-place", explanation: "Selection sort is in-place, using only O(1) extra space." },
  { id: "ss15", topic: "Sorting & Searching", difficulty: 3, question: "Is merge sort an in-place sorting algorithm?", choices: ["Yes", "No", "Only for arrays", "Only for linked lists", "Depends on implementation"], answer: 1, hint: "Merge sort needs extra arrays during the merge step", explanation: "Merge sort is NOT in-place — it requires O(n) additional space for merging." },
];
