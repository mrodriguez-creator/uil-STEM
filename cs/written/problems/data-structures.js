// UIL Computer Science – Data Structures & Algorithms
const DATA_STRUCTURES_PROBLEMS = [

  // ── SORTING ALGORITHMS ──
  { id: "ds1", topic: "Data Structures & Algorithms", question: "Which sorting algorithm has a worst-case time complexity of O(n²) but a best-case of O(n)?", choices: ["Mergesort", "Selection Sort", "Insertion Sort", "Quicksort", "Radix Sort"], answer: 2, hint: "This sort is efficient on nearly-sorted data because it can skip already-ordered elements", explanation: "Insertion Sort: best case O(n) when array is already sorted, worst case O(n²) when reversed." },
  { id: "ds2", topic: "Data Structures & Algorithms", question: "What is the time complexity of Mergesort in the worst case?", choices: ["O(n)", "O(n log n)", "O(n²)", "O(log n)", "O(2<sup>n</sup>)"], answer: 1, hint: "Mergesort divides in half (log n levels) and merges n elements at each level", explanation: "Mergesort always runs in O(n log n) — it divides the array in half recursively and merges." },
  { id: "ds3", topic: "Data Structures & Algorithms", question: "Which sort works by repeatedly finding the minimum element and placing it in order?", choices: ["Bubble Sort", "Insertion Sort", "Selection Sort", "Quicksort", "Mergesort"], answer: 2, hint: "This sort 'selects' the smallest remaining element each pass", explanation: "Selection Sort finds the minimum element in the unsorted portion and swaps it into position." },
  { id: "ds4", topic: "Data Structures & Algorithms", question: "After one complete pass of Bubble Sort on <code>[5, 3, 8, 1, 2]</code>, the array becomes:", choices: ["[1, 2, 3, 5, 8]", "[3, 5, 1, 2, 8]", "[1, 3, 5, 2, 8]", "[3, 5, 8, 1, 2]", "[2, 1, 3, 5, 8]"], answer: 1, hint: "Bubble sort compares adjacent pairs and swaps if out of order. The largest bubbles to the end.", explanation: "Pass 1: (5,3)→swap [3,5,8,1,2], (5,8)→ok, (8,1)→swap [3,5,1,8,2], (8,2)→swap [3,5,1,2,8]. Result: [3,5,1,2,8]." },
  { id: "ds5", topic: "Data Structures & Algorithms", question: "What is the worst-case time complexity of Quicksort?", choices: ["O(n)", "O(n log n)", "O(n²)", "O(log n)", "O(n³)"], answer: 2, hint: "Occurs when the pivot is always the smallest or largest element", explanation: "Quicksort worst case is O(n²) when the pivot is always the extreme value (already sorted input with bad pivot choice)." },

  // ── SEARCHING ──
  { id: "ds6", topic: "Data Structures & Algorithms", question: "What is the time complexity of binary search?", choices: ["O(1)", "O(log n)", "O(n)", "O(n log n)", "O(n²)"], answer: 1, hint: "Each comparison eliminates half the remaining elements", explanation: "Binary search halves the search space each step → O(log n)." },
  { id: "ds7", topic: "Data Structures & Algorithms", question: "What is the time complexity of linear (sequential) search in the worst case?", choices: ["O(1)", "O(log n)", "O(n)", "O(n log n)", "O(n²)"], answer: 2, hint: "In the worst case, you must check every element", explanation: "Linear search checks each element. Worst case: element is last or not present → O(n)." },

  // ── BIG-O ANALYSIS ──
  { id: "ds8", topic: "Data Structures & Algorithms", question: "What is the Big-O of this code?<pre><code>for (int i = 0; i < n; i++)\n  for (int j = 0; j < n; j++)\n    sum++;</code></pre>", choices: ["O(1)", "O(n)", "O(n log n)", "O(n²)", "O(n³)"], answer: 3, hint: "Two nested loops, each running n times", explanation: "Two nested loops, each iterating n times: n × n = O(n²)." },
  { id: "ds9", topic: "Data Structures & Algorithms", question: "What is the Big-O of this code?<pre><code>for (int i = 1; i < n; i *= 2)\n  sum++;</code></pre>", choices: ["O(1)", "O(log n)", "O(n)", "O(n log n)", "O(n²)"], answer: 1, hint: "i doubles each iteration, so it takes log₂(n) steps to reach n", explanation: "i doubles each step: 1, 2, 4, 8, ... needs log₂(n) steps → O(log n)." },
  { id: "ds10", topic: "Data Structures & Algorithms", question: "What is the Big-O of this code?<pre><code>for (int i = 0; i < n; i++)\n  for (int j = 0; j < 1000; j++)\n    sum++;</code></pre>", choices: ["O(1)", "O(n)", "O(1000n)", "O(n²)", "O(n × 1000)"], answer: 1, hint: "The inner loop runs a constant 1000 times regardless of n", explanation: "Inner loop is O(1000) = O(1). Total: n × O(1) = O(n)." },
  { id: "ds11", topic: "Data Structures & Algorithms", question: "Which Big-O represents the best performance for large n?", choices: ["O(n²)", "O(n log n)", "O(n)", "O(log n)", "O(1)"], answer: 4, hint: "Constant time doesn't grow with input size", explanation: "O(1) < O(log n) < O(n) < O(n log n) < O(n²). O(1) is best." },
  { id: "ds12", topic: "Data Structures & Algorithms", question: "How many times does the print statement execute?<pre><code>for (int i = 0; i < n; i++)\n  for (int j = i; j < n; j++)\n    System.out.println(\"*\");</code></pre>", choices: ["n", "n²", "n(n+1)/2", "n log n", "2<sup>n</sup>"], answer: 2, hint: "i=0: n times, i=1: n&minus;1 times, ... i=n&minus;1: 1 time", explanation: "n + (n−1) + ... + 1 = n(n+1)/2. This is O(n²)." },

  // ── RECURSION ──
  { id: "ds13", topic: "Data Structures & Algorithms", question: "What is the output?<pre><code>int f(int n) {\n  if (n <= 1) return 1;\n  return n * f(n - 1);\n}\nSystem.out.println(f(5));</code></pre>", choices: ["15", "24", "60", "120", "720"], answer: 3, hint: "This computes n! (factorial). 5! = 120", explanation: "f(5) = 5×4×3×2×1 = 120." },
  { id: "ds14", topic: "Data Structures & Algorithms", question: "What is the output?<pre><code>void mystery(int n) {\n  if (n > 0) {\n    mystery(n - 1);\n    System.out.print(n + \" \");\n  }\n}\nmystery(4);</code></pre>", choices: ["\"4 3 2 1 \"", "\"1 2 3 4 \"", "\"4 \"", "\"1 \"", "Infinite recursion"], answer: 1, hint: "The print happens AFTER the recursive call (post-order)", explanation: "Recursive calls before print: mystery(0) returns, then prints 1, 2, 3, 4. Output: \"1 2 3 4 \"." },
  { id: "ds15", topic: "Data Structures & Algorithms", question: "What is the output?<pre><code>int f(int n) {\n  if (n == 0) return 0;\n  if (n == 1) return 1;\n  return f(n-1) + f(n-2);\n}\nSystem.out.println(f(6));</code></pre>", choices: ["5", "6", "8", "10", "13"], answer: 2, hint: "This is the Fibonacci sequence: 0,1,1,2,3,5,8", explanation: "Fibonacci: f(0)=0, f(1)=1, f(2)=1, f(3)=2, f(4)=3, f(5)=5, f(6)=8." },

  // ── TREES (BST) ──
  { id: "ds16", topic: "Data Structures & Algorithms", question: "In a Binary Search Tree, which traversal visits nodes in sorted order?", choices: ["Preorder", "Inorder", "Postorder", "Level-order", "Reverse preorder"], answer: 1, hint: "This traversal processes left subtree, then root, then right subtree", explanation: "Inorder traversal (Left, Root, Right) of a BST visits nodes in ascending sorted order." },
  { id: "ds17", topic: "Data Structures & Algorithms", question: "A BST has nodes: 50, 30, 70, 20, 40, 60, 80. What is the inorder traversal?", choices: ["50 30 20 40 70 60 80", "20 30 40 50 60 70 80", "20 40 30 60 80 70 50", "50 30 70 20 40 60 80", "80 70 60 50 40 30 20"], answer: 1, hint: "Inorder traversal of a BST gives sorted order", explanation: "Inorder of BST always gives sorted order: 20, 30, 40, 50, 60, 70, 80." },
  { id: "ds18", topic: "Data Structures & Algorithms", question: "What is the height of a complete binary tree with 15 nodes?", choices: ["2", "3", "4", "5", "7"], answer: 1, hint: "A complete binary tree with 2<sup>h+1</sup>&minus;1 nodes has height h", explanation: "2⁴ − 1 = 15. So the tree has 4 levels, height = 3 (counting from 0), or 4 levels." },
  { id: "ds19", topic: "Data Structures & Algorithms", question: "What is the preorder traversal of this BST?<pre>    10\n   /  \\\n  5    15\n / \\     \\\n3   7    20</pre>", choices: ["3 5 7 10 15 20", "10 5 3 7 15 20", "3 7 5 20 15 10", "10 15 20 5 3 7", "5 3 7 10 15 20"], answer: 1, hint: "Preorder: Root, Left, Right", explanation: "Preorder: 10, then left subtree (5, 3, 7), then right subtree (15, 20). Result: 10 5 3 7 15 20." },

  // ── GRAPH BASICS ──
  { id: "ds20", topic: "Data Structures & Algorithms", question: "What is the time complexity of BFS on a graph with V vertices and E edges?", choices: ["O(V)", "O(E)", "O(V + E)", "O(V × E)", "O(V²)"], answer: 2, hint: "BFS visits each vertex once and examines each edge once", explanation: "BFS explores all vertices and edges: O(V + E)." },
  { id: "ds21", topic: "Data Structures & Algorithms", question: "Which data structure does BFS (Breadth-First Search) use?", choices: ["Stack", "Queue", "Heap", "Array", "Linked List"], answer: 1, hint: "BFS explores level by level, using FIFO ordering", explanation: "BFS uses a Queue (FIFO) to explore vertices level by level." },
  { id: "ds22", topic: "Data Structures & Algorithms", question: "Which data structure does DFS (Depth-First Search) typically use?", choices: ["Queue", "Stack (or recursion)", "Heap", "Hash Table", "Linked List"], answer: 1, hint: "DFS goes deep before backtracking, which matches LIFO behavior", explanation: "DFS uses a Stack (LIFO) — either explicitly or through the call stack via recursion." },

  // ── HASH TABLES ──
  { id: "ds23", topic: "Data Structures & Algorithms", question: "What is the average time complexity for lookup in a hash table?", choices: ["O(1)", "O(log n)", "O(n)", "O(n log n)", "O(n²)"], answer: 0, hint: "Hash tables provide constant-time access on average", explanation: "Hash table lookup is O(1) on average (assuming a good hash function and low load factor)." },
  { id: "ds24", topic: "Data Structures & Algorithms", question: "What is a hash collision?", choices: ["When a hash table is full", "When two keys map to the same index", "When a key is null", "When the hash function returns negative", "When the table needs resizing"], answer: 1, hint: "A collision occurs when different keys produce the same hash value or index", explanation: "A collision occurs when two different keys hash to the same bucket/index in the table." },

  // ── HEAPS & PRIORITY QUEUES ──
  { id: "ds25", topic: "Data Structures & Algorithms", question: "In a min-heap, where is the smallest element?", choices: ["At a leaf node", "At the last position", "At the root", "It varies", "At the leftmost leaf"], answer: 2, hint: "Min-heap property: parent ≤ children at every node", explanation: "In a min-heap, the root always contains the minimum element." },
  { id: "ds26", topic: "Data Structures & Algorithms", question: "What is the time complexity of inserting into a binary heap?", choices: ["O(1)", "O(log n)", "O(n)", "O(n log n)", "O(n²)"], answer: 1, hint: "Insert at the bottom and bubble up — the height is log n", explanation: "Insert at the end and sift up. The height of the heap is O(log n), so insert is O(log n)." },

  // ── LINKED LISTS ──
  { id: "ds27", topic: "Data Structures & Algorithms", question: "What is the time complexity of inserting at the head of a singly linked list?", choices: ["O(1)", "O(log n)", "O(n)", "O(n log n)", "O(n²)"], answer: 0, hint: "Create a new node, point it to the current head, update head", explanation: "Inserting at the head is O(1): create node, set next to current head, update head pointer." },
  { id: "ds28", topic: "Data Structures & Algorithms", question: "What is the time complexity of accessing the kth element of a singly linked list?", choices: ["O(1)", "O(log n)", "O(k)", "O(n)", "O(n²)"], answer: 2, hint: "You must traverse from the head, following next pointers one by one", explanation: "No random access in linked lists. Must traverse k nodes from the head: O(k)." },

  // ── GREEDY ALGORITHMS ──
  { id: "ds29", topic: "Data Structures & Algorithms", question: "Which algorithm finds the shortest path from a single source in a weighted graph with non-negative edges?", choices: ["Kruskal's", "Prim's", "Dijkstra's", "BFS", "DFS"], answer: 2, hint: "This algorithm uses a priority queue and relaxes edges greedily", explanation: "Dijkstra's algorithm finds the shortest path from one source vertex, using a greedy approach with a priority queue." },
  { id: "ds30", topic: "Data Structures & Algorithms", question: "Which algorithms find a Minimum Spanning Tree?", choices: ["Dijkstra's and BFS", "Kruskal's and Prim's", "DFS and BFS", "Quicksort and Mergesort", "Floyd-Warshall and Bellman-Ford"], answer: 1, hint: "MST algorithms: one grows a tree vertex by vertex, the other adds edges by weight", explanation: "Kruskal's (sort edges, add cheaply using union-find) and Prim's (grow tree from a vertex) both find MSTs." },

  // ── FINITE STATE MACHINES ──
  { id: "ds31", topic: "Data Structures & Algorithms", question: "A Finite State Machine (FSM) consists of:", choices: ["States, transitions, and an input alphabet", "Variables, methods, and classes", "Nodes, edges, and weights", "Stacks, queues, and arrays", "Threads, locks, and monitors"], answer: 0, hint: "An FSM has a set of states, input symbols, and transition rules", explanation: "An FSM is defined by its states, input alphabet, transition function, start state, and accept states." },
  { id: "ds32", topic: "Data Structures & Algorithms", question: "A deterministic finite automaton (DFA) is in state S1 and reads input 'a'. It transitions to S2. What determines S2?", choices: ["Only the input 'a'", "Only the current state S1", "Both the current state and the input", "The previous state", "Random selection"], answer: 2, hint: "In a DFA, the next state is determined by current state + input", explanation: "In a DFA, the transition function δ(state, input) = next_state. Both current state and input determine the next state." },
];
