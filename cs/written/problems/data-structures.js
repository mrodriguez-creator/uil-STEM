// UIL Computer Science – Data Structures & Algorithms
// BST, Big-O through code, sorting, graphs — UIL authentic format
const DATA_STRUCTURES_PROBLEMS = [

  // ── BIG-O THROUGH CODE (UIL Q18/Q27 style) ──

  { id: "ds1", topic: "Data Structures & Algorithms", question: "What is the asymptotic time complexity of the code to the right?<pre><code>PriorityQueue&lt;Integer&gt; pq;\npq = new PriorityQueue&lt;&gt;\n    (Collections.reverseOrder());\nfor(int y = 0; y < N; y++) {\n    double d = Math.random() * 100;\n    pq.add((int)(d));\n}\nout.println(pq);</code></pre>", choices: ["O(N log N)", "O(N)", "O(N²)", "O(log N)", "O(N² log N)"], answer: 0, hint: "PriorityQueue.add() is O(log N). Called N times in the loop", explanation: "The loop runs N times. Each pq.add() is O(log N) for a heap. Total: O(N log N)." },

  { id: "ds2", topic: "Data Structures & Algorithms", question: "What is the asymptotic time complexity of the code to the right?<pre><code>int sum = 0;\nfor(int y = 0; y < 12; y++)\n    for(int x = y; x >= 10; x--)\n        sum += x;\nout.println(sum);</code></pre>", choices: ["O(N log N)", "O(N)", "O(N²)", "O(1)", "O(N² log N)"], answer: 3, hint: "All loop bounds are constants (12, 10) — they don't depend on any input N", explanation: "Both loops have constant bounds (12 and 10). No variable input size. This is O(1) — constant time regardless of input." },

  { id: "ds3", topic: "Data Structures & Algorithms", question: "What is the asymptotic time complexity of the code to the right?<pre><code>for(int i = 1; i < N; i *= 2)\n    out.print(i + \" \");</code></pre>", choices: ["O(N)", "O(N²)", "O(log N)", "O(N log N)", "O(2ᴺ)"], answer: 2, hint: "i doubles each iteration: 1, 2, 4, 8, 16... How many doublings until i >= N?", explanation: "i doubles each iteration. After k iterations, i = 2ᵏ. Loop stops when 2ᵏ >= N, so k = log₂(N). O(log N)." },

  { id: "ds4", topic: "Data Structures & Algorithms", question: "What is the asymptotic time complexity of the code to the right?<pre><code>for(int i = 0; i < N; i++)\n    for(int j = i; j < N; j++)\n        sum++;</code></pre>", choices: ["O(N)", "O(N log N)", "O(N²)", "O(N³)", "O(2ᴺ)"], answer: 2, hint: "Inner loop runs N-i times for each i. Total = N + (N-1) + ... + 1 = N(N+1)/2", explanation: "Total iterations = N + (N-1) + ... + 1 = N(N+1)/2 = O(N²)." },

  // ── DATA STRUCTURE IDENTIFICATION ──

  { id: "ds5", topic: "Data Structures & Algorithms", question: "Which data structure is demonstrated by the code to the right?<pre><code>PriorityQueue&lt;Integer&gt; pq;\npq = new PriorityQueue&lt;&gt;\n    (Collections.reverseOrder());\nfor(int y = 0; y < N; y++) {\n    double d = Math.random() * 100;\n    pq.add((int)(d));\n}\nout.println(pq);</code></pre>", choices: ["Queue", "Min-Heap", "Linked List", "Max-Heap", "Stack"], answer: 3, hint: "PriorityQueue with Collections.reverseOrder() creates a max-first ordering", explanation: "PriorityQueue with reverseOrder comparator creates a Max-Heap — largest element has highest priority." },

  { id: "ds6", topic: "Data Structures & Algorithms", question: "Which of the following pairings does <em>not</em> properly match the data structure to the worst-case asymptotic time complexity of the operation?", choices: ["O(1) random access using an Array", "O(1) find min using a Min-Heap", "O(log n) search using a Tree Set", "O(1) search using a Hash Set", "O(log n) search using a Binary Search Tree"], answer: 4, hint: "An unbalanced BST can degenerate into a linked list", explanation: "An unbalanced BST has worst-case O(n) search (when degenerate). O(log n) is average case, not worst case. E is the mismatch." },

  // ── BST QUESTIONS (text-based, UIL Q31-Q34 style) ──

  { id: "ds7", topic: "Data Structures & Algorithms", question: "Assume the elements below are inserted in order into an initially empty, unbalanced Binary Search Tree where duplicates are not added.<pre><code>34, 86, 28, 29, 33, 14, 52, 31,\n92, 14, 15, 92, 31, 92, 105, 95,\n97, 118</code></pre>How many internal nodes (non-leaf) will the tree have?", choices: ["10", "9", "8", "7", "6"], answer: 1, hint: "Remove duplicates first (14, 92, 31 appear again). Insert remaining 14 unique values in order and count nodes with at least one child", explanation: "Unique values inserted: 34,86,28,29,33,14,52,31,92,15,105,95,97,118 (14 nodes). After building the BST, there are 9 internal nodes and 5 leaf nodes." },

  { id: "ds8", topic: "Data Structures & Algorithms", question: "Using the same BST from the previous question, how many leaf nodes will the tree have?", choices: ["3", "4", "5", "6", "7"], answer: 2, hint: "Leaf nodes have no children. Build the tree and identify nodes at the ends of branches", explanation: "After building the BST with 14 unique values, the leaf nodes are: 15, 31, 52, 97, 118. That's 5 leaf nodes." },

  { id: "ds9", topic: "Data Structures & Algorithms", question: "What is the worst-case time complexity for the <code>search()</code> operation in an unbalanced Binary Search Tree? Assume <code>n</code> is the number of elements.", choices: ["O(log n)", "O(n²)", "O(n)", "O(√n)", "O(n log n)"], answer: 2, hint: "An unbalanced BST can degenerate into a linked list", explanation: "Worst case: BST degenerates to a linked list (all nodes on one side). Search traverses all n nodes. O(n)." },

  // ── SORTING ALGORITHM IDENTIFICATION ──

  { id: "ds10", topic: "Data Structures & Algorithms", question: "What is output by the code to the right after one complete pass of the outer loop?<pre><code>int[] arr = {5, 3, 8, 1, 9, 2};\nfor(int i = 0; i < arr.length - 1; i++) {\n    if(arr[i] > arr[i + 1]) {\n        int t = arr[i];\n        arr[i] = arr[i + 1];\n        arr[i + 1] = t;\n    }\n}\nout.println(Arrays.toString(arr));</code></pre>", choices: ["[1, 2, 3, 5, 8, 9]", "[3, 5, 1, 8, 2, 9]", "[3, 5, 8, 1, 2, 9]", "[5, 3, 8, 1, 2, 9]", "There is no output due to a runtime error."], answer: 1, hint: "This is one pass of bubble sort — trace each comparison and swap", explanation: "Pass: [5,3]→swap→[3,5,8,1,9,2]. [5,8]→no. [8,1]→swap→[3,5,1,8,9,2]. [8,9]→no. [9,2]→swap→[3,5,1,8,2,9]. Output: [3, 5, 1, 8, 2, 9]." },

  { id: "ds11", topic: "Data Structures & Algorithms", question: "Which sorting algorithm divides the array into two halves, recursively sorts each half, and then merges them back together?", choices: ["Quicksort", "Insertion Sort", "Merge Sort", "Selection Sort", "Heap Sort"], answer: 2, hint: "The key word is 'merges' — which algorithm has a merge step?", explanation: "Merge Sort: divide in half, recursively sort each half, then merge the sorted halves." },

  { id: "ds12", topic: "Data Structures & Algorithms", question: "Which of the following algorithms can be used to calculate the length of the minimum spanning tree of a weighted, undirected graph?", choices: ["Kruskal's Algorithm", "Floyd-Warshall Algorithm", "Ford-Fulkerson Algorithm", "Prim's Algorithm", "Both A and D"], answer: 4, hint: "Two classic MST algorithms: one greedy by edges, one greedy by vertices", explanation: "Both Kruskal's (greedy by edge weight) and Prim's (greedy by vertex expansion) find the MST. Answer: Both A and D." },

  // ── GRAPH QUESTIONS (text-based) ──

  { id: "ds13", topic: "Data Structures & Algorithms", question: "What is the best-known asymptotic time complexity of Kruskal's Algorithm for finding a minimum spanning tree?", choices: ["O(V log V)", "O(E log V)", "O(E)", "O(V²)", "None of the above"], answer: 1, hint: "Kruskal's sorts edges and uses union-find", explanation: "Kruskal's: sort edges O(E log E) = O(E log V), then union-find operations are nearly O(E). Total: O(E log V)." },

  { id: "ds14", topic: "Data Structures & Algorithms", question: "Given a directed graph with the following edges:<pre><code>A→B, A→C, B→D, C→D, C→E,\nD→F, E→F</code></pre>Starting from vertex A, which of the following is a valid BFS traversal order?", choices: ["A, B, C, D, E, F", "A, C, B, E, D, F", "A, B, D, C, E, F", "A, B, C, E, D, F", "Both A and B"], answer: 4, hint: "BFS visits all neighbors first. From A: B and C (either order). Then from B: D. From C: D(visited), E. Then F", explanation: "BFS from A: visit A, queue [B,C]. Visit B→queue D. Visit C→queue E (D already seen). Visit D→queue F. Visit E→F already queued. Visit F. Both A,B,C,D,E,F and A,C,B,E,D,F are valid BFS orderings depending on neighbor processing order." },

  // ── RECURSION ──

  { id: "ds15", topic: "Data Structures & Algorithms", question: "What is output by the code to the right?<pre><code>public int recur(int i) {\n    if(i < 0)\n        return 1;\n    if(i % 5 < 2)\n        return recur(i - 2) +\n               recur(i - 3);\n    else\n        return recur(i - 2);\n}\n//client code:\nout.println(recur(10));</code></pre>", choices: ["5", "8", "12", "13", "There is no output due to a runtime error."], answer: 1, hint: "Trace the recursion tree: recur(10)→10%5=0<2→recur(8)+recur(7). Continue expanding", explanation: "recur(10): 10%5=0<2 → recur(8)+recur(7). recur(8): 8%5=3≥2 → recur(6). recur(7): 7%5=2≥2 → recur(5). recur(6): 6%5=1<2 → recur(4)+recur(3). recur(5): 5%5=0<2 → recur(3)+recur(2). recur(4): 4%5=4≥2 → recur(2). recur(3): 3%5=3≥2 → recur(1). recur(2): 2%5=2≥2 → recur(0). recur(1): 1%5=1<2 → recur(-1)+recur(-2)=1+1=2. recur(0): 0%5=0<2 → recur(-2)+recur(-3)=1+1=2. So recur(2)=recur(0)=2. recur(3)=recur(1)=2. recur(4)=recur(2)=2. recur(5)=recur(3)+recur(2)=2+2=4. recur(6)=recur(4)+recur(3)=2+2=4. recur(7)=recur(5)=4. recur(8)=recur(6)=4. recur(10)=4+4=8." },

  { id: "ds16", topic: "Data Structures & Algorithms", question: "What is output by the code to the right?<pre><code>public int f(int n) {\n    if(n <= 1) return n;\n    return f(n - 1) + f(n - 2);\n}\n//client code:\nout.println(f(7));</code></pre>", choices: ["7", "8", "13", "21", "There is no output due to a runtime error."], answer: 2, hint: "This is the Fibonacci sequence: f(0)=0, f(1)=1, f(2)=1, f(3)=2, ...", explanation: "Fibonacci: f(0)=0, f(1)=1, f(2)=1, f(3)=2, f(4)=3, f(5)=5, f(6)=8, f(7)=13." },

  { id: "ds17", topic: "Data Structures & Algorithms", question: "What is output by the code to the right?<pre><code>public static int mystery(int n) {\n    if(n < 10) return n;\n    return n % 10 + mystery(n / 10);\n}\n//client code:\nout.println(mystery(4821));</code></pre>", choices: ["4", "8", "12", "15", "There is no output due to a runtime error."], answer: 3, hint: "This recursively sums the digits of n", explanation: "mystery(4821) = 1 + mystery(482) = 1 + 2 + mystery(48) = 1 + 2 + 8 + mystery(4) = 1+2+8+4 = 15." },

  // ── BINARY SEARCH ──

  { id: "ds18", topic: "Data Structures & Algorithms", question: "What is output by the code to the right?<pre><code>int[] arr = {2, 5, 8, 12, 16, 23, 38};\nint idx = Arrays.binarySearch(arr, 16);\nout.println(idx);</code></pre>", choices: ["3", "4", "5", "-5", "There is no output due to a runtime error."], answer: 1, hint: "binarySearch returns the index of the found element. 16 is at index 4", explanation: "Array is sorted. 16 is at index 4. binarySearch returns 4." },

  { id: "ds19", topic: "Data Structures & Algorithms", question: "What is output by the code to the right?<pre><code>int[] arr = {2, 5, 8, 12, 16, 23, 38};\nint idx = Arrays.binarySearch(arr, 10);\nout.println(idx);</code></pre>", choices: ["-1", "-3", "-4", "3", "There is no output due to a runtime error."], answer: 2, hint: "When element is not found, binarySearch returns -(insertion point) - 1", explanation: "10 would be inserted at index 3 (between 8 and 12). Return: -(3)-1 = -4." },

  // ── HASH TABLE CONCEPTS ──

  { id: "ds20", topic: "Data Structures & Algorithms", question: "What is the average-case time complexity for search in a well-implemented hash table?", choices: ["O(1)", "O(log n)", "O(n)", "O(n log n)", "O(n²)"], answer: 0, hint: "Hash tables use a hash function for direct access", explanation: "Average case: hash function distributes evenly, so lookup is O(1). Worst case (all collisions) is O(n)." },

  // ── LINKED LIST / ABSTRACT DATA TYPE ──

  { id: "ds21", topic: "Data Structures & Algorithms", question: "A class <code>DataStructure&lt;T&gt;</code> has methods <code>addFront(T)</code>, <code>addBack(T)</code>, <code>removeFront()</code>, and <code>removeBack()</code>. This is a partial implementation of what well-known data structure?", choices: ["Dequeue", "AVL Tree", "Stack", "Min-Heap", "Queue"], answer: 0, hint: "Which data structure supports insertion and removal from both ends?", explanation: "A Deque (double-ended queue) supports add/remove from both front and back." },

  // ── TRAVERSALS ──

  { id: "ds22", topic: "Data Structures & Algorithms", question: "A binary search tree contains the values 1 through 7. Its inorder traversal is <code>1, 2, 3, 4, 5, 6, 7</code> and its preorder traversal is <code>4, 2, 1, 3, 6, 5, 7</code>. What is its postorder traversal?", choices: ["1, 3, 2, 5, 7, 6, 4", "1, 2, 3, 5, 7, 6, 4", "7, 6, 5, 3, 2, 1, 4", "1, 3, 2, 7, 5, 6, 4", "None of the above"], answer: 0, hint: "Preorder first element (4) is root. Inorder splits into left (1,2,3) and right (5,6,7)", explanation: "Root=4. Left subtree inorder: 1,2,3; preorder: 2,1,3 → root=2, left=1, right=3. Right subtree inorder: 5,6,7; preorder: 6,5,7 → root=6, left=5, right=7. Postorder: 1,3,2,5,7,6,4." },

  // ── CONSIDER BINARY SEARCH TREES ──

  { id: "ds23", topic: "Data Structures & Algorithms", question: "Consider a series of four (potentially identical) binary search trees created from 20 arbitrary, but distinct (no duplicate) values. If we denote the maximum width as w<sub>max</sub>, minimum width as w<sub>min</sub>, maximum height as h<sub>max</sub>, and minimum height as h<sub>min</sub>, what are these four values in order: w<sub>max</sub>, w<sub>min</sub>, h<sub>max</sub>, h<sub>min</sub>?<br>(Height counts edges, not vertices.)", choices: ["8, 1, 19, 4", "10, 1, 19, 4", "8, 1, 20, 4", "8, 1, 19, 3", "None of the above"], answer: 0, hint: "Max height = n-1 (degenerate). Min height = floor(log₂(n)). Max width is at the widest level of a balanced tree", explanation: "20 nodes. h_max = 19 (degenerate/linear, height = edges = n-1). h_min = floor(log₂(20)) = 4. For a complete binary tree with 20 nodes: levels 0-3 have 1+2+4+8=15 nodes. Level 3 has 8 nodes, which is the widest level. w_max = 8. w_min = 1 (degenerate tree). Answer: 8, 1, 19, 4." },

  // ── ADJACENCY MATRIX ──

  { id: "ds24", topic: "Data Structures & Algorithms", question: "A directed graph has 5 vertices (A-E) and the following edges: A→B, A→C, B→D, C→B, C→E, D→E, E→A. How many zeros appear in its 5×5 adjacency matrix?", choices: ["15", "17", "18", "19", "20"], answer: 2, hint: "The adjacency matrix is 5×5 = 25 cells. Count the 1s (one per edge), rest are 0s", explanation: "7 edges = 7 ones in the matrix. 25 - 7 = 18 zeros." },

  { id: "ds25", topic: "Data Structures & Algorithms", question: "What is the asymptotic time complexity of inserting an element into a balanced Binary Search Tree (e.g., AVL tree) with <code>n</code> nodes?", choices: ["O(1)", "O(log n)", "O(n)", "O(n log n)", "O(n²)"], answer: 1, hint: "A balanced BST has height O(log n). Insertion traverses from root to a leaf", explanation: "In a balanced BST, the height is O(log n). Insertion follows a path from root to a leaf position, which takes O(log n) time." },

  // ── SELECTION SORT & INSERTION SORT IDENTIFICATION ──

  { id: "ds26", topic: "Data Structures & Algorithms", question: "Which sorting algorithm is implemented by the code to the right?<pre><code>for (int i = 0; i < arr.length - 1; i++) {\n    int minIdx = i;\n    for (int j = i + 1; j < arr.length; j++)\n        if (arr[j] < arr[minIdx])\n            minIdx = j;\n    int temp = arr[i];\n    arr[i] = arr[minIdx];\n    arr[minIdx] = temp;\n}</code></pre>", choices: ["Bubble Sort", "Insertion Sort", "Selection Sort", "Merge Sort", "Quick Sort"], answer: 2, hint: "The inner loop finds the minimum element from the unsorted portion, then swaps it into position", explanation: "Selection Sort: find the minimum element in the unsorted portion (i+1 to end), swap it with position i. Repeat for each position." },

  { id: "ds27", topic: "Data Structures & Algorithms", question: "Which sorting algorithm is implemented by the code to the right?<pre><code>for (int i = 1; i < arr.length; i++) {\n    int key = arr[i];\n    int j = i - 1;\n    while (j >= 0 && arr[j] > key) {\n        arr[j + 1] = arr[j];\n        j--;\n    }\n    arr[j + 1] = key;\n}</code></pre>", choices: ["Bubble Sort", "Insertion Sort", "Selection Sort", "Merge Sort", "Quick Sort"], answer: 1, hint: "The algorithm takes each element and shifts larger elements right to make room, then inserts it in the correct position", explanation: "Insertion Sort: take each element (key), shift all larger elements in the sorted portion one position right, then insert the key in its correct position." },

  { id: "ds28", topic: "Data Structures & Algorithms", question: "What is the array after the <strong>first complete pass</strong> of Selection Sort on the following array?<pre><code>{8, 3, 5, 1, 9, 2}</code></pre>", choices: ["{1, 3, 5, 8, 9, 2}", "{3, 5, 1, 8, 2, 9}", "{1, 8, 3, 5, 9, 2}", "{3, 8, 5, 1, 9, 2}", "{1, 2, 3, 5, 8, 9}"], answer: 0, hint: "Selection Sort finds the minimum of the entire array and swaps it with position 0", explanation: "First pass: find minimum in {8,3,5,1,9,2} → min is 1 at index 3. Swap arr[0] and arr[3]: {1, 3, 5, 8, 9, 2}." },

  { id: "ds29", topic: "Data Structures & Algorithms", question: "What is the array after the <strong>first complete pass</strong> of Insertion Sort on the following array?<pre><code>{5, 2, 8, 1, 9}</code></pre>(Insertion Sort starts with the second element.)", choices: ["{2, 5, 8, 1, 9}", "{1, 2, 5, 8, 9}", "{2, 5, 1, 8, 9}", "{5, 2, 1, 8, 9}", "{1, 5, 2, 8, 9}"], answer: 0, hint: "First pass: key = arr[1] = 2. Compare with arr[0] = 5. Since 5 > 2, shift 5 right and insert 2", explanation: "Pass 1 (i=1): key = 2. arr[0]=5 > 2, shift right: {5,5,8,1,9}. Insert 2 at position 0: {2, 5, 8, 1, 9}." },

  // ── XOR SWAP TRICK ──

  { id: "ds30", topic: "Data Structures & Algorithms", question: "What is output by the code to the right?<pre><code>int x = 12, y = 7;\nx ^= y;\ny ^= x;\nx ^= y;\nout.println(x + \" \" + y);</code></pre>", choices: ["12 7", "7 12", "0 0", "5 5", "There is no output due to a compile error."], answer: 1, hint: "XOR swap: after x^=y, y^=x, x^=y the values of x and y are exchanged", explanation: "XOR swap trick: x^=y → x=12^7=11. y^=x → y=7^11=12. x^=y → x=11^12=7. Final: x=7, y=12. Output: \"7 12\"." },

  // ── BST DIAMETER ──

  { id: "ds31", topic: "Data Structures & Algorithms", question: "The <em>diameter</em> of a binary tree is the length (in edges) of the longest path between any two nodes. What is the diameter of a balanced BST containing the values 1 through 7 with root 4?<pre><code>        4\n       / \\\n      2   6\n     / \\ / \\\n    1  3 5  7</code></pre>", choices: ["2", "3", "4", "5", "6"], answer: 2, hint: "The longest path goes from a leaf on the left subtree to a leaf on the right subtree, passing through the root", explanation: "Longest path: 1→2→4→6→7 (or 1→2→4→6→5, or 3→2→4→6→7, etc.). Each has 4 edges. Diameter = 4." },
];
